#!/usr/bin/env bash
# shellcheck disable=SC2059
# vim: filetype=sh

# Author: Prasad Tengse
# Licence: GPLv3
# Github Repository: https://github.com/tprasadtp/ubuntu-post-install
# Requirements - Bash v4 and above
#              - whiptail, wget, iputils-ping, awk, sed, grep
#

readonly AE_EXEC_START=$(date +%s)
readonly SCRIPT=$(basename "$0")

case "${DEBUG}" in
  1 | "yes" | "true" | "TRUE")     AE_DEBUG=1;set -o pipefail;;
  "internal")                      AE_DEBUG=2;set -o pipefail;;
  "ci" | "CI")                     AE_DEBUG=2;set -eo pipefail;;
  "trace")                         AE_DEBUG=3;set -o pipefail;;
  *)                               AE_DEBUG=0;set -o pipefail;;
esac

# SCRIPT METADATA
readonly dir=$(cd -P -- "$(dirname -- "$0")" && pwd -P)
readonly REL_NAME="6.0-RC4"
readonly REL_NUM=602

# YQ Version to use
readonly YQ_VERSION="3.3.0"

function _init_printf_variables()
{
  #Initialize printf variables

    #================ Because I care about Beauty of Output Logs =================
    readonly           _repo="[    Add-Repo   ]"
    readonly            _ppa="[      PPA      ]"
    readonly          _oh_no="[     Oh No!    ]"
    readonly     _installing="[   Installing  ]"
    readonly      _installed="[   Installed   ]"
    readonly        _removed="[    Removed    ]"
    readonly       _deleting="[    Deleting   ]"
    readonly      _linuxmint="[  Linux - Mint ]"
    readonly     _elementary="[ Elementary-OS ]"
    readonly          _purge="[     Purge     ]"
    readonly          _error="[     Error!    ]"
    readonly         _update="[     Update    ]"
    readonly        _upgrade="[    Upgrade    ]"
    readonly   _distribution="[     Distro    ]"
    readonly      _conflicts="[   Conflicts   ]"
    readonly         _notice="[    Notice     ]"
    readonly            _deb="[   Debian-PKG  ]"
    readonly           _info="[     Info      ]"
    readonly       _simulate="[   Simulating  ]"
    readonly            _fix="[      Fix      ]"
    readonly           _warn="[    Warning    ]"
    readonly         _whoops="[     Oops!     ]"
    readonly    _pre_release="[  Pre Release  ]"
    readonly    _new_release="[  New Release  ]"
    readonly        _version="[    Version    ]"
    readonly       _checking="[    Checking   ]"
    readonly            _eol="[      EOL      ]"
    readonly        _running="[    Running    ]"
    readonly      _autopilot="[   Autopilot   ]"
    readonly           _exit="[      Exit     ]"
    readonly          _debug="[     DEBUG     ]"
    readonly       _internal="[    INTERNAL   ]"
    readonly          _trace="[     TRACE     ]"
    readonly       _ppa_logs="[    PPA-Logs   ]"
    readonly       _apt_logs="[    APT-Logs   ]"
    readonly      _dpkg_logs="[    PKG-Logs   ]"
    readonly   _apt_key_logs="[  APT-Key-Logs ]"
    readonly       _pip_logs="[    PIP-Logs   ]"
    readonly            _cfg="[     Config    ]"
    readonly         _rtasks="[     Tasks     ]"
    readonly             _ci="[      C-I      ]"
    readonly       _internet="[    Internet   ]"
    readonly          _table="[  ---Table---  ]"
    readonly          _array="[   PKG Array   ]"
    readonly            _apt="[  APT-Packges  ]"
    readonly           _snap="[    Snap PKG   ]"
    readonly             _ok="[       OK      ]"
    readonly       _dev_mode="[    Testing    ]"

    #colors for display
    readonly YELLOW=$'\e[33m'
    readonly GREEN=$'\e[32m'
    readonly ORANGE=$'\e[38;5;209m'
    readonly RED=$'\e[31m'
    readonly BLUE=$'\e[34m'
    readonly NC=$'\e[0m'
    readonly MAGENTA=$'\e[35m'
    readonly GRAY=$'\e[38;5;247m'
    readonly LOG_GRAY=$'\e[38;5;241m'
    readonly INTERNAL_GRAY=$'\e[38;5;244m'
}


function _init_logging()
{
  # Initialize phase 2
  # Only variables necessary for logging & start logging
  # Script related variables are defined in _init_script_variables
  readonly log_file="$dir"/logs/after-effects.log
  {
    mkdir -p "$dir"/logs
  } ||
  {
    printf "${RED}${_error} Failed to create logs folder${NC}\n"; exit 2
  }
  # tmp dir
  {
    rm -rf /tmp/ae/*
    mkdir -p /tmp/ae/
  } ||
  {
    printf "${RED}${_error} Failed to create tmp folder${NC}\n"; exit 2
  }

  # if file not exists touch it
  if [[ ! -f ${log_file} ]]; then
    if touch "${log_file}"; then
      printf "${GRAY}${_debug} Created Log file${NC}\n"
    else
      printf "${GRAY}${_debug} Failed to create logfile!${NC}\n"
      exit 2
    fi
  fi

  # check if logs can be written
  if [[ -w $log_file ]]; then
    {
      _log_debug "Initialize logging for RUN ID: ${CLIENT_ID}"
    } ||
    {
      printf "${RED}${_error} Failed to write to log file ${log_file} ${NC}\n"; exit 2
    }
  else
    printf "${RED}${_error} Log File is not writable!${NC}\n"
    exit 2
  fi
}


# Utility Functions
function _line_fill()
{
   if [[ ! -t 1 ]]; then
    printf "_______________________________________________________\n"
  else
    printf "%-$(tput cols)s@%s\n" | sed -e "s/ /-/g" -e "s/-@/ /" -e "s/@-/ /"
  fi
}


function set_blue()
{
  printf "${BLUE}"
}


function set_yellow()
{
  printf "${YELLOW}"
}

function set_green()
{
  printf "${GREEN}"
}

function set_orange()
{
  printf "${ORANGE}"
}


function set_magenta()
{
  printf "${MAGENTA}"
}


function set_red()
{
  printf "${RED}"
}


function set_log_gray()
{
  printf "${LOG_GRAY}"
}

function set_default()
{
  printf "${NC}"
}


function _log_and_exit()
{
  # ARG-1 log msg
  # ARG-2 exit code int
  local msg="$1"
  printf "${RED}${_exit} $msg${NC}\n";
  {
    printf "[$(date)]${_exit} ${msg}\n" >> "$log_file";
    printf "\nFinished ${SCRIPT} on $(date).\nExit code: $(date)\n"
  } >> "$log_file"
  _line_fill
  _line_fill >> "$log_file"
  exit "$2"
}


function _script_exit_log()
{
    # Script time
    readonly AE_EXEC_END=$(date +%s)
    readonly AE_EXEC_TIME=$(( AE_EXEC_END - AE_EXEC_START ))

    # Generate Exit message & log
    _log_debug "Exiting Script"
    _log_debug "Finished $SCRIPT in $AE_EXEC_TIME seconds, on $(date).\n"
    _line_fill >> "$log_file"

    printf "\n* ${GREEN}Show your support by starring this repo on GitHub.${NC}"
    printf "\n* ${GREEN}Link - https://git.io/Jv08V${NC}\n"

    return 0
}

function _log_and_show()
{
  local msg="$1"
  printf "$msg\n"
  printf "[$(date)] $msg\n" >> "$log_file"
}


function _log_debug()
{
  local msg="$1"
  if [[ ${AE_DEBUG} -gt 0 ]]; then
    printf "${GRAY}${_debug} $msg${NC}\n"
  fi
  printf "[$(date)] ${_debug} $msg\n" >> "$log_file"
}


function _log_success()
{
  local msg="$1"
  printf "${GREEN}$msg ${NC}\n"
  printf "[$(date)] $msg\n" >> "$log_file"
}

function _log_warn()
{
  local msg="$1"
  printf "${YELLOW}${_warn} $msg ${NC}\n"
  printf "[$(date)] $msg\n" >> "$log_file"
}

function _log_dev()
{
  local msg="$1"
  printf "${ORANGE}${_dev_mode} $msg ${NC}\n"
  printf "[$(date)] ${_dev_mode} $msg\n" >> "$log_file"
}

function _log_internal()
{
  local msg="$1"
  if [[ $AE_DEBUG -gt 1 ]]; then
    printf "${INTERNAL_GRAY}${_internal} $msg ${NC}\n"
  fi
  printf "[$(date)]${_internal} $msg\n" >> "$log_file"
}

function _log_trace()
{
  local msg="$1"
  if [[ $AE_DEBUG -gt 2 ]]; then
    printf "${LOG_GRAY}${_trace} $msg ${NC}\n"
  fi
  printf "[$(date)] $msg\n" >> "$log_file"
}

function _log_notice()
{
  local msg="$1"
  printf "${BLUE}$msg ${NC}\n"
  printf "[$(date)] $msg\n" >> "$log_file"
}

function _log_error()
{
  local msg="$1"
  printf "${RED}${_error} $msg ${NC}\n"
  printf "[$(date)] $msg\n" >> "$log_file"
}

function _log_info()
{
  local msg="$1"
  printf "$msg ${NC}\n"
  printf "[$(date)] $msg\n" >> "$log_file"
}

#shellcheck disable=SC2120
function detect_distribution()
{
  # Read /etc/os-release and get
  local OS_RELEASE_FILE

  OS_RELEASE_FILE="${1:-/etc/os-release}"
  if [[ -r "${OS_RELEASE_FILE}" ]]; then
    _log_debug "Found os-release file ${OS_RELEASE_FILE}, attemping to read it."
    # Read Version Code Name
    readonly AE_DISTRO_CODENAME="$(awk '/VERSION_CODENAME=/' "${OS_RELEASE_FILE}" | sed 's/VERSION_CODENAME=//' | tr '[:upper:]' '[:lower:]')"

    # Read Human Readable Full Version Name
    readonly AE_DISTRO_PRETTY_NAME="$(awk '/PRETTY_NAME=/' "${OS_RELEASE_FILE}" | sed 's/PRETTY_NAME=//' | tr -d '"')"

    # Read Human Readable Distro Name
    readonly AE_DISTRO_NAME="$(awk '/^NAME=/' "${OS_RELEASE_FILE}" | sed 's/^NAME=//' | tr -d '"')"
  else
    _log_error "Hey, What are you running this script on?"
    _log_and_exit "I cannot determine distro/codename!" "5"
  fi
}


function _init_script_variables()
{
  # Function defines Script variables
  # Necessary variables used by the script are initialized here. This function
  # should be called first before choices are made, always.

  #shellcheck disable=SC2119
  detect_distribution

  # Achtung: Do not set code_name as readonly!!
  code_name="${AE_DISTRO_CODENAME}"
  readonly architecture="$(dpkg --print-architecture)"
  case "${architecture}" in
    amd64)          _log_debug "Architecture is 64 bit.";
                    readonly ARCH="amd64";
                    readonly YQ_BIN_ARCH="amd64";
                    ;;
    i386)           _log_debug "Architecture is 32 bit.";
                    _log_and_exit "i386 is no longer Supported!" "11"
                    ;;
    armhf)          _log_debug "Running on ARM CPU with HW Floating point Processor";
                    readonly ARCH="armhf";
                    readonly YQ_BIN_ARCH="arm";
                    ;;
    arm64)           _log_debug "This is an ARM 64. Please be advised that not all repositories support this arch.";
                    readonly ARCH="arm64";
                    readonly YQ_BIN_ARCH="arm";
                    ;;
    * )             _log_error "Sorry! This architecture is not supported by this script!"
                    _log_and_exit "Unsupported Architecture. $(architecture)" "11"
                    ;;
  esac

  # Get Hostname
  readonly CLIENT_NAME=$(hostname)

  # etc sources list dir
  readonly SOURCES_FILE_DIR=/etc/apt/sources.list.d

  # Ping URL
  readonly PING_URL="www.google.com"


  #-------------------------- Release codenames --------------------------------------
  readonly code_name_latest_release="focal"
  readonly codename_previous_release="eoan"
  readonly codename_upcoming_release="groovy"
  readonly codename_lts_fallback="focal"
  readonly code_name_latest_debian_release="buster"
  readonly codename_upcoming_debian_release="bullseye"

  #============================ Switches/ booleans & Vars ================================


  # Fix Repo not available for latest release
  bool_fix_repo_not_available_for_latest="false"


  # Allow repo fixes for Upcoming releases of ubuntu and its derivatives.
  bool_fix_repo_not_available_for_upcoming_release="false"

  # Checks for Version
  # Define API node endpoints

  bool_check_version="true"

  readonly api_version_url="https://ae.prasadt.com/get/v3/version"


  # Achtung!!
  # ========================================================================================= #

  # Purge not required packages
  # Default is false
  # Requires command line option -d to be passed via command line otherwise it will not work.
  # Set this to true if you don't want to pass -d every time
  bool_purge_not_required_pkgs="false"

  # Say yes to all (No whiptail dialogs)
  # Default is false
  # Can be set to true and dialog boxes will be skipped if command line option -y is passed.
  # Set this to true if you don't want to pass -y every time
  bool_say_yes_to_all="false"

  # Keep Downloaded DEB packages
  bool_preserve_debs="false"

  #
  # ================================================================================== #
  # Achtung!
  # Do not change any of the variables below this if you don't know what they do.
  # They are essential for correct working of the script or use unstable builds/repos.

  # Check Debian Flags
  bool_is_debian="false"

  # Check Signature
  #readonly bool_verify_gpg_signatures="true"

  # Azure
  readonly AZURE_METADATA_URL="http://169.254.169.254/metadata/instance/compute/location?api-version=2017-08-01&format=text"

}


function _init_print_basic_info()
{
  # This function logs and displays the Necessary details which helps in debugging.
  # Should be used after _init_script_variables function.
  _log_notice "${_info} Hostname    : ${CLIENT_NAME}"
  _log_notice "${_info} OS          : ${AE_DISTRO_PRETTY_NAME}"
  _log_notice "${_info} Distro      : ${AE_DISTRO_NAME}"
  _log_notice "${_info} Code Name   : ${AE_DISTRO_CODENAME}"
  _log_notice "${_info} Arch        : ${ARCH}"
  _log_debug  "Path for sources.list.d: ${SOURCES_FILE_DIR}"
  _log_success "${_version} ${REL_NAME} - ${REL_NUM}"

  #disable hist chars  so that I can print "!!"" properly
  histchars=
}


function delete_log_file()
{
  printf "${_deleting} log file...\n"
  if rm "${dir}/logs/after-effects.log"; then
    set_green
    printf "${GREEN}${_ok} Deleted log file %s\n" "$log_file"
    set_default
    exit 0
  else
    set_red
    printf "${_error} Deleting log file failed. %s\n" "$log_file"
    exit 1;
  fi
}


function  _add_timestamp_to_logs()
{
  # This function adds time stamp to logs without using external utilities
  # Output will be automatically written to $log_file
  # Arguments : 1
  # ARG -1: printf variable for formatting the log
  # Usage command | _add_timestamp_to_logs "$1"
  while IFS= read -r line;
  do
    printf "[$(date)] ${1} %s\n" "$line" &>> "$log_file"
    if [[ $AE_DEBUG -gt 2 ]]; then
      printf "${LOG_GRAY}${1} %s${NC}\n" "$line"
    fi
  done

}


function _check_dependencies()
{
  #Checks if commands in array are available.
  # Accepts one argument as array.
  local dependencies=("$@")
  local dependency_check_failed_count dep_res dependency
  dependency_check_failed_count=0;
  _log_and_show "${_info} Checking dependencies..."
  for dependency in "${dependencies[@]}"; do
   command -v "$dependency" > /dev/null
   dep_res=$?
   if [ "$dep_res" -eq 1 ]; then
     _log_error "$dependency is not installed!${NC}"
     dependency_check_failed_count=$((dependency_check_failed_count+1))
   fi
  done

  if [ "$dependency_check_failed_count" -gt 0 ]; then
    _log_error "One or more dependencies not installed."
    _log_and_exit "Sorry! $SCRIPT cannot continue!" "1"
  fi
}


function __disp_sig_check_passed()
{
  # Displays message after --verify proves that the GPG signatures match
  set_green
  printf "OK! Signature verified!\n"
  set_default
}


function __disp_sig_check_failed()
{
  # Displays failed GPG signature message
  set_red;
  printf "Oh No! Signature checks failed.\n"
  printf "File is either corrupt or has been modified.\n"
  set_default;
}


function verify_gpg_signature()
{
  # Verifies the file with its detached GPG signature.
  # Assumes that you already have public key in your keyring.
  # Assumes signature file is present at same location,
  # with same name but with .sig or .gpg or .asc extension.
  local sig_file
  # Checks if file is present
  if [ -f "${SCRIPT}.sig" ]; then
    sig_file="${SCRIPT}.sig"
  elif [ -f "${SCRIPT}.asc" ]; then
    sig_file="${SCRIPT}.asc"
  elif [ -f "${SCRIPT}.gpg" ]; then
    sig_file="${SCRIPT}.gpg"
  else
    printf "${YELLOW}Error! Signature file not found.${NC}\n"
    exit 51;
  fi

  # Check for signature files
  printf "Verifying GPG signature of file..\n"
  printf "Signature File : ${sig_file}\n"
  printf "Data File      : $(basename $SCRIPT)\n"
  set_default
  # Checks for commands
  if command -v gpg > /dev/null; then
    if gpg --verify "${sig_file}" "${SCRIPT}" >/dev/null  2>&1; then
      __disp_sig_check_passed
    else
      __disp_sig_check_failed
      exit 50;
    fi
  elif command -v gpgv >/dev/null; then
    if gpgv --keyring "$HOME/.gnupg/pubring.kbx" "${sig_file}" "${SCRIPT}" > /dev/null  2>&1; then
      __disp_sig_check_passed
    else
      __disp_sig_check_failed
      exit 50;
    fi
  else
    printf "Cannot perform verification. gpgv or gpg is not installed."
    printf "This action requires gnugpg/gnupg2 or gpgv package.\n"
    exit 1;
  fi

}


function _eol_message()
{
  # Display EOL Message and upgrade instruction URLs.
  # Arguments: 1
  # ARG 1: EOL Date

  _log_error "This version of ${AE_DISTRO_NAME} is no longer supported."
  _log_and_exit "${_eol} ${AE_DISTRO_PRETTY_NAME} reached EOL on $1." "12"
}


function _fix_ubuntu_derivatives()
{
  # Some Ubuntu based distributions use their own codename (Linux mint, Elementary)
  # Some repositories require that ubuntu codename is used.
  # This function fixes that for
  # Linux mint 17.X : Ubuntu 14.04 Trusty,
  # Linux mint 18.x : Ubuntu 16.04 Xenial,
  # Linux mint 19.x : Ubuntu 18.04 Xenial,
  # Elementary OS Loki : Ubuntu 14.04 Trusty,
  # Elementary OS Freya: Ubuntu 16.04 Xenial
  # Elementary OS Juno,Hera: Ubuntu 18.04 Xenial
  # Pop!_OS uses Ubuntu codenames (No need to apply fix)
  # KDE Neon, Bodhi, Peppermint use Ubuntu codenames
  # If the release is not known this function exits the script for safety.

  _log_and_show "${_distribution} Checking..."
  _log_debug "Variable code_name is : $code_name"
  case ${code_name} in
      sarah | serena | sonya | sylvia )     _log_and_show "${_linuxmint} Release is Linux mint 18.X."
                                            _log_and_show "${_linuxmint} Setting additional repositories to follow Ubuntu 16.04."
                                            code_name="xenial";
                                            readonly distro_name="ubuntu";
                                            readonly enable_ppa="true";
                                            _log_success "${_linuxmint} Changed codename to $code_name"
                                            ;;
      tara | tessa | tina | tricia)         _log_and_show "${_linuxmint} Release is Linux mint 19.X."
                                            _log_and_show "${_linuxmint} Setting additional repositories to follow Ubuntu 18.04."
                                            code_name="bionic";
                                            readonly distro_name="ubuntu";
                                            readonly enable_ppa="true";
                                            _log_success "${_linuxmint} Changed codename to $code_name"
                                            ;;
      loki )                                _log_and_show "${_elementary} This release of Elementary OS is based on Ubuntu 16.04 Xenial."
                                            _log_and_show "${_elementary} External repositories will use Ubuntu 16.04."
                                            code_name="xenial";
                                            readonly distro_name="ubuntu";
                                            readonly enable_ppa="true";
                                            _log_success "${_elementary} Changed codename to $code_name"
                                            ;;
      juno | hera)                          _log_and_show "${_elementary} This release of Elementary OS is based on Ubuntu 18.04 Bionic."
                                            _log_and_show "${_elementary} External repositories will use Ubuntu 18.04."
                                            code_name="bionic";
                                            readonly distro_name="ubuntu";
                                            readonly enable_ppa="true";
                                            _log_success "${_elementary} Changed codename to $code_name"
                                            ;;
      xenial | bionic )                     readonly bool_config_partner_repo="true";
                                            readonly enable_ppa="true";
                                            readonly distro_name="ubuntu";
                                            _log_and_show "${_distribution} This is a LTS release of Ubuntu"
                                            _log_success "${_distribution} Keeping the codename as: $code_name."
                                            ;;
      focal )                               readonly bool_config_partner_repo="true";
                                            readonly python2_disabled="true";
                                            readonly enable_ppa="true";
                                            readonly distro_name="ubuntu";
                                            _log_and_show "${_distribution} This is latest LTS release of Ubuntu"
                                            _log_success "${_distribution} Keeping the codename as: $code_name."
                                            ;;
      ulyana)                               _log_and_show "${_linuxmint} Release is Linux mint 20.X."
                                            _log_and_show "${_linuxmint} Setting additional repositories to follow Ubuntu 20.04."
                                            code_name="focal";
                                            readonly python2_disabled="true";
                                            readonly distro_name="ubuntu";
                                            readonly enable_ppa="true";
                                            _log_success "${_linuxmint} Changed codename to $code_name"
                                            ;;
      eoan)                                 readonly bool_config_partner_repo="true";
                                            readonly enable_ppa="true";
                                            readonly distro_name="ubuntu";
                                            _log_and_show "${_distribution} This is 19.10 eoan."
                                            if [[ $bool_fix_repo_not_available_for_latest != "true" ]] && [[ $bool_fix_lts != "true"  ]] ; then _log_notice "${_notice} If your repos are not yet supported, use --fix option"; fi
                                            _log_success "${_distribution} Keeping the codename as: $code_name."
                                            ;;
      groovy )                              readonly bool_config_partner_repo="true";
                                            readonly enable_ppa="false";
                                            readonly distro_name="ubuntu";
                                            set_magenta;
                                            _log_and_show "${_pre_release} This is Ubuntu 20.10 Groovy"
                                            set_default
                                            _log_warn "PPAs are disabled!"
                                            _log_warn "This is pre-release version of Ubuntu, Use with caution!"
                                            ;;
      stretch | jessie | buster )           bool_is_debian="true";
                                            readonly distro_name="debian";
                                            readonly enable_ppa="false";
                                            _log_notice "${_distribution} This is Debian. PPAs are disabled."
                                            ;;
      bullseye)                             bool_is_debian="true";
                                            readonly enable_ppa="false";
                                            readonly distro_name="debian";
                                            _log_warn "You are running Debian Testing!"
                                            _log_warn "This is pre release version of Debian. Use with caution!"
                                            _log_notice "${_notice} PPAs are disabled."
                                            ;;
      disco )                               _eol_message "January 23rd, 2020"
                                            ;;
      *)                                    _log_error "Unknown Distribution/Release."
                                            _log_notice "${_notice} This Script is not designed to run on this ($code_name) distro/release."
                                            _script_exit_log;
                                            exit 16;
                                            ;;
  esac
  set_default;

}


function _test_internet_connection ()
{
  # Function to check internet connection
  _log_and_show "${_internet} Checking connectivity"
  if wget --tries=5 --timeout=2 "$PING_URL" -O /tmp/ae/testinternet &>/dev/null 2>&1; then
    rm -f /tmp/ae/testinternet
    _log_success "${_internet} Connected!"
  else
    _log_error "Booooooo! You are not connected to the Internet!. "
    _log_error "Please check your Internet connection and try again."
    rm -f /tmp/ae/testinternet || _log_debug "Failed to remove temp network connectivity resp file"
    _log_and_exit "No internet connection!" "14"
  fi
}


function _test_conflicting_apps ()
{
  # Function checks if any apps like syanptic aptitude are running.
  local lock
  _log_and_show "${_conflicts} Checking..."
  for lock in synaptic update-manager software-center apt-get dpkg aptitude
  do
    # shellcheck disable=SC2009
    if ps -U root -u root u | grep $lock | grep -v grep > /dev/null; then
      _log_and_exit "Installation won't work. Please close $lock first then try again." "15"
    else
      _log_debug "$lock is not running."
     fi
   done
   _log_success "${_conflicts} None detected."
}




function parse_yaml() {
  local yaml_file="${1}"
  local prefix="${2}"
  local s
  local w
  local fs

  s='[[:space:]]*'
  w='[a-zA-Z0-9_.-]*'
  fs="$(echo @|tr @ '\034')"

    (
        #shellcheck disable=SC1003
        sed -e '/- [^\"]'"[^\']"'.*: /s|\([ ]*\)- \([[:space:]]*\)|\1-\'$'\n''  \1\2|g' |

        sed -ne '/^--/s|--||g; s|\"|\\\"|g; s/[[:space:]]*$//g;' \
            -e "/#.*[\"\']/!s| #.*||g; /^#/s|#.*||g;" \
            -e "s|^\($s\)\($w\)$s:$s\"\(.*\)\"$s\$|\1$fs\2$fs\3|p" \
            -e "s|^\($s\)\($w\)${s}[:-]$s\(.*\)$s\$|\1$fs\2$fs\3|p" |

      awk -F"$fs" '{
          indent = length($1)/2;
          if (length($2) == 0) { conj[indent]="+";} else {conj[indent]="";}
          vname[indent] = $2;
          for (i in vname) {if (i > indent) {delete vname[i]}}
              if (length($3) > 0) {
                  vn=""; for (i=0; i<indent; i++) {vn=(vn)(vname[i])("__")}
                  printf("%s%s%s%s=(\"%s\")\n", "'"$prefix"'",vn, $2, conj[indent-1],$3);
              }
          }' |

        sed -e 's/_=/+=/g' |

        awk 'BEGIN {
                FS="=";
                OFS="="
            }
            /(-|\.).*=/ {
                gsub("-|\\.", "_", $1)
            }
            { print }'
) < "$yaml_file"
}


function _get_remote_file()
{
  # Function to get remote file/response
  # exits script if it fails.
  # Accepts 2 arguments.
  # ARG 1: File name; Name of the local file the response or file should be saved as.
  # ARG 2: URL to the  file

  local file_name="${1}"
  local exit_status;
  local file_url="${2}"
  _log_debug "Remote file URL is set to ${file_url}"

  if [ "$#" -eq 2 ]; then
    # Remote files
    wget -q "${file_url}" -O "$file_name" >> $"$log_file"
    exit_status="$?"

    _log_debug "Exit code from wget is : $exit_status"
    if [[ $exit_status -eq 0 ]]; then
      _log_debug "Successfully retrieved file."
    else
      _log_error "Something went wrong while retrieving ${file_name}."
      _log_and_exit "Error Getting file." "28"
    fi
  else
    _log_and_exit "Invalid number of arguments <_get_remote_file> Requires 2, got $#." "19"
  fi

}

function _verify_yq()
{
  local expected_shasum="${1}"
  local shasum

  __file_shasum="$(sha256sum "${dir}/yq")"

  _log_info "${_parser} Verifying..."
  _log_debug "Verifying checksums for ${dir}/yq"

  if echo "${shasum} ${dir}/yq" | sha256sum -c -; then
    _log_success "${_parser} checksums match!"
  else
    _log_internal "Got ${__file_shasum} instead of ${expected_shasum}"
    set_orange
    _log_info "${_report} Please report this error! https://git.io/Jv08"
    set_default
    _log_and_exit "Error! Parser binary verification failed!" "62"
  fi

}

function __download_yq()
{
  _get_remote_file "yq" "${YQ_DOWNLOAD_URL}"
  _verify_yq "${YQ_CHECKSUM}"
}

function _version_checks ()
{
  # Checks if its running latest version.
  # Also suggest updating to latest version if current version is not latest,
  # Allows to deprecate old version as it can be suggested.
  # Check if Version Checks is enabled. (Default is enabled)
  if [ "$bool_check_version" == "true" ]; then
      _log_debug "Version Checks are enabled."
      _log_and_show "${_version} Checking for Updates..."
      if [ "$bool_custom_version_file" != "true" ]; then
        _log_debug "Using version config file."
        _log_debug "Deleting old Version YAMLS"
        rm -f "/tmp/ae/api-version.yml" || _log_debug "Deleting old version YAML failed."
        readonly version_yaml_file="/tmp/ae/api-version.yml"
        # Get response/file
        _get_remote_file "$version_yaml_file" "$api_version_url"
      else
        _log_and_show "${_cfg} Using local Version file : $custom_version_file"
        readonly version_yaml_file="$custom_version_file"
      fi

      # Parse YAML to variables
      _log_debug "Parsing Version Config File"
      eval "$(parse_yaml "$version_yaml_file")"
      # Assign them to local variables as sometimes bash if does not handle array elements very well.
      local api_rel_num="${version__number[0]}"

      # Assign Statistics reporting flag and endpoint to Global variables.
      # Debug Info
      _log_debug "Version from API: ${api_rel_num}"

      # If release number is higher than one in the script throw error & ask to update.
      if [[ $api_rel_num -gt $REL_NUM ]]; then
        _log_warn "A newer version is available.\n${_version} Please download latest version and try again."
        _log_warn "You are running version ${REL_NAME} with version number ${REL_NUM}."
        _log_and_show "Latest available version is ${version__name[0]}-${api_rel_num}."
        _log_and_exit "${_version} You can disable version checks by passing\n${_version} --skip-version-check" "24"
      elif [[ $api_rel_num -eq $REL_NUM ]]; then
        _log_success "${_version} All Good!"
      elif [[ $api_rel_num -lt $REL_NUM ]]; then
        _log_dev "You are running version ${REL_NAME} - ${REL_NUM}."
        _log_dev "Latest stable version is ${version__name[0]}-${api_rel_num}."
      fi

  # If version checks have been disabled
  else
    _log_warn "Version checks have been disabled."
  fi
  #sleep 5

}


function _check_bool()
{
  # Function to check if config has valid values for bool.
  # Accepted values are true and false
  # If invalid, defaults to false.
  # Accepts global var and bool to check as arguments
  local g_var param_bool default_val
  if [[ $# -eq 2 ]]; then
    default_val="false"
  else
    _log_and_exit "Internal error! bool validator takes only two arguments!" "19"
  fi

  g_var="${1}"
  param_bool="${2}"
  case "${param_bool}" in
    true | True | TRUE | Yes | yes | YES | 1 )  declare -g ${g_var}="true"
                                                _log_internal "$g_var is set to true"
                                                ;;
    false | False | FALSE | No | no | NO | 0 )  declare -g ${g_var}="false"
                                                _log_internal "$g_var is set to false"
                                                ;;
    *)                                          declare -g ${g_var}="${default_val}"
                                                _log_internal "$g_var will default to ${default_val}"
                                                ;;
  esac
}


function _set_yaml_config()
{

  # Get and parse the file
  _log_and_show "${_cfg} Processing..."
  if [ "$bool_custom_config_file" != "true" ]; then
    _log_and_show "${_cfg} ${url_remote_yaml}."
    _log_debug "Deleting old YAMLS"
    rm -f "/tmp/ae/api-config.yml" || _log_debug "Deleting old version YAML failed."
    readonly config_yaml_file="/tmp/ae/api-config.yml"
    # Get response/file
    _get_remote_file "$config_yaml_file" "$url_remote_yaml"
  else
    _log_and_show "${_cfg} Using local config file : $custom_config_file"
    readonly config_yaml_file="$custom_config_file"
  fi

  # Parse YAML to variables
  _log_debug "Parsing Config File "
  eval "$(parse_yaml "$config_yaml_file")"


  set_default;
  # Repo flags
  #################################################################################
  _check_bool "add_docker_repo" "${config__add_repo__docker[0]}"
  #add_docker_repo="${config__add_repo__docker[0]}"

  _check_bool "add_winehq_repo" "${config__add_repo__winehq[0]}"
  #add_winehq_repo="${config__add_repo__winehq[0]}"

  _check_bool "add_mendeley_repo" "${config__add_repo__mendeley[0]}"
  #add_mendeley_repo="${config__add_repo__mendeley[0]}"

  _check_bool "add_googlecloud_repo" "${config__add_repo__googlecloud[0]}"
  #add_googlecloud_repo="${config__add_repo__googlecloud[0]}"
  _check_bool "add_gcsfuse_repo" "${config__add_repo__gcsfuse[0]}"

  _check_bool "add_spotify_repo" "${config__add_repo__spotify[0]}"
  #add_spotify_repo="${config__add_repo__spotify[0]}"

  _check_bool "add_skype_repo" "${config__add_repo__skype[0]}"
  #add_skype_repo="${config__add_repo__skype[0]}"

  _check_bool "add_vscode_repo" "${config__add_repo__vscode[0]}"
  #add_vscode_repo="${config__add_repo__vscode[0]}"

  _check_bool "add_insync_repo" "${config__add_repo__insync[0]}"
  #add_insync_repo="${config__add_repo__insync[0]}"

  _check_bool "add_signal_repo" "${config__add_repo__signal[0]}"
  #add_signal_repo="${config__add_repo__signal[0]}"

  _check_bool "add_google_repo" "${config__add_repo__google[0]}"
  #add_google_repo="${config__add_repo__google[0]}"

  # ROS
  _check_bool "add_ros_repo" "${config__add_repo__ros[0]}"

  # DUO
  _check_bool "add_duo_repo" "${config__add_repo__duo[0]}"

  # Other Script Flags
  #################################################################################

  # Purge Packages
  _check_bool "bool_purge_not_required_pkgs" "${config__flags__purge_enabled[0]}"
  #bool_purge_not_required_pkgs="${config__flags__purge_enabled[0]}"

  # Keep Debs
  _check_bool "bool_preserve_debs" "${config__flags__preserve_debs[0]}"
  #bool_preserve_debs="${config__flags__preserve_debs[0]}"

  # Uni-Mirror
  _check_bool "bool_use_uni_freiburg_mirror" "${config__flags__uni_freiburg_mirror[0]}"

  # Tasks Flags
  ##################################################################################

  #ae_task_update="${config__tasks__update[0]}"
  _check_bool "ae_task_update" "${config__tasks__update[0]}"

  #ae_task_upgrade="${config__tasks__upgrade[0]}"
  _check_bool "ae_task_upgrade" "${config__tasks__upgrade[0]}"

  #ae_task_repo="${config__tasks__repo[0]}"
  _check_bool "ae_task_repo" "${config__tasks__repo[0]}"

  #ae_task_ppa="${config__tasks__ppa[0]}"
  _check_bool "ae_task_ppa" "${config__tasks__ppa[0]}"

  #ae_task_apt="${config__tasks__apt[0]}"
  _check_bool "ae_task_apt" "${config__tasks__apt[0]}"

  #ae_task_debs="${config__tasks__debs[0]}"
  _check_bool "ae_task_debs" "${config__tasks__debs[0]}"

  #ae_task_purge="${config__tasks__purge[0]}"
  _check_bool "ae_task_purge" "${config__tasks__purge[0]}"

  #ae_task_pip2="${config__tasks__pip2[0]}"
  _check_bool "ae_task_pip2" "${config__tasks__pip2[0]}"

  #ae_task_pip3="${config__tasks__pip3[0]}"
  _check_bool "ae_task_pip3" "${config__tasks__pip3[0]}"

  # Binaries Install
  _check_bool "ae_task_bin" "${config__tasks__binaries[0]}"

  # snap Packages
  _check_bool "ae_task_snaps" "${config__tasks__snaps[0]}"


  if [[ ${bool_hide_config} != "true" ]] && [[ $AE_DEBUG -lt 1 ]]; then
    _line_fill
    printf "${_table} %-20s | %-10s |\n" "Repository" "Enabled"
    printf "${_cfg} %-20s | %-10s |\n" "Docker CE" "$add_docker_repo"
    printf "${_cfg} %-20s | %-10s |\n" "Wine-HQ" "$add_winehq_repo"
    printf "${_cfg} %-20s | %-10s |\n" "Google Cloud SDK" "$add_googlecloud_repo"
    printf "${_cfg} %-20s | %-10s |\n" "GCSFUSE" "$add_gcsfuse_repo"
    printf "${_cfg} %-20s | %-10s |\n" "Spotify" "$add_spotify_repo"
    printf "${_cfg} %-20s | %-10s |\n" "Skype" "$add_skype_repo"
    printf "${_cfg} %-20s | %-10s |\n" "Visual Studio Code" "$add_vscode_repo"
    printf "${_cfg} %-20s | %-10s |\n" "Insync" "$add_insync_repo"
    printf "${_cfg} %-20s | %-10s |\n" "Signal for Desktop" "$add_signal_repo"
    printf "${_cfg} %-20s | %-10s |\n" "Google Chrome, Earth" "$add_google_repo"
    printf "${_cfg} %-20s | %-10s |\n" "ROS" "$add_ros_repo"
    _line_fill;
    printf "${_table} %-20s | %-10s |\n" "Other Flags" "Config"
    _line_fill;
    printf "${_cfg} %-20s | %-10s |\n" "Purge Enabled" "$bool_purge_not_required_pkgs"
    printf "${_cfg} %-20s | %-10s |\n" "Keep DEBs/APT cache" "$bool_preserve_debs"
    printf "${_cfg} %-20s | %-10s |\n" "Uni-Freiburg Mirror" "$bool_use_uni_freiburg_mirror"
    _line_fill;

    # Only display tasks column when autopilot = true is set.
    if [[ ${AE_AUTOPILOT} == "true" ]]; then
      printf "${_table} %-20s | %-10s |\n" "Task" "Config"
      _line_fill;
      printf "${_rtasks} %-20s | %-10s |\n" "Update" "$ae_task_update"
      printf "${_rtasks} %-20s | %-10s |\n" "Upgrade" "$ae_task_upgrade"
      printf "${_rtasks} %-20s | %-10s |\n" "Add Repos" "$ae_task_repo"
      printf "${_rtasks} %-20s | %-10s |\n" "Add PPA" "$ae_task_ppa"
      printf "${_rtasks} %-20s | %-10s |\n" "APT packages" "$ae_task_apt"
      printf "${_rtasks} %-20s | %-10s |\n" "DEB packages" "$ae_task_debs"
      printf "${_rtasks} %-20s | %-10s |\n" "Purge packages" "$ae_task_purge"
      printf "${_rtasks} %-20s | %-10s |\n" "Python 2 Modules" "$ae_task_pip2"
      printf "${_rtasks} %-20s | %-10s |\n" "Python 3 Modules" "$ae_task_pip3"
      printf "${_rtasks} %-20s | %-10s |\n" "Static Binaries" "$ae_task_bin"
      printf "${_rtasks} %-20s | %-10s |\n" "Snap Packages" "$ae_task_snaps"
      _line_fill;
    fi
  else
    _log_debug "-------- REPO CONFIG ----------"
    _log_debug "Docker CE           : $add_docker_repo"
    _log_debug "Wine-HQ             : $add_winehq_repo"
    _log_debug "Google Cloud SDK    : $add_googlecloud_repo"
    _log_debug "GCSFUSE             : $add_gcsfuse_repo"
    _log_debug "Spotify             : $add_spotify_repo"
    _log_debug "Skype               : $add_skype_repo"
    _log_debug "Visual Studio Code  : $add_vscode_repo"
    _log_debug "Insync              : $add_insync_repo"
    _log_debug "Signal for Desktop  : $add_signal_repo"
    _log_debug "Google Chrome,Earth : $add_google_repo"
    _log_debug "ROS                 : $add_ros_repo"
    _log_debug "-------- FLAG CONFIG ----------"
    _log_debug "Purge Enabled       : $bool_purge_not_required_pkgs"
    _log_debug "Keep DEBs/APT cache : $bool_preserve_debs"
    _log_debug "Use Uni Mirror      : $bool_use_uni_freiburg_mirror"
    _log_debug "-------- TASK CONFIG ----------"
    _log_debug " AUTOPILOT IS ${AE_AUTOPILOT}"
    _log_debug "Update              : $ae_task_update"
    _log_debug "Upgrade             : $ae_task_upgrade"
    _log_debug "Add Repos           : $ae_task_repo"
    _log_debug "Add PPA             : $ae_task_ppa"
    _log_debug "APT packages        : $ae_task_apt"
    _log_debug "DEB packages        : $ae_task_debs"
    _log_debug "Purge packages      : $ae_task_purge"
    _log_debug "Python 2 Modules    : $ae_task_pip2"
    _log_debug "Python 3 Modules    : $ae_task_pip3"
    _log_debug "Static Binaries     : $ae_task_bin"
    _log_debug "Snap Packages       : $ae_task_snaps"
    _log_debug "--------  END CONFIG ----------"
  fi
  #################################################################################
  #                              Parse Arrays
  #################################################################################
  # Config file YAML has arrays of apt packages.
  # We need to parse apt packages, ppa's, deb packages, python modules listed in yaml
  # to bash arrays.

  #--------------------------------------------------------------------------------
  #                               APT Lists
  #--------------------------------------------------------------------------------
  # There are Seven lists under key config.install.apt.[mentioned from 1-7]
  # 1. administration : Contains Administrative packages
  # 2. security       : contains Security related tools and packages
  # 3. productivity   : Office tools, writing tools, LateX, document tools and other
  #                     productivity tools, Email clients, browsers, IM clients etc.
  #                   : Example : LateX, TeXStudio, Libre office, pandoc empathy, Thunderbird
  # 4. Multimedia     : Multimedia tools like media players, audio converters and playes etc.
  # 5. development    : IDEs [Spyder, Jetbeans etc], languages [go, python, ruby, rust, java etc],
  #                   : Containers [docker lxc rkt etc], Python libraries, compilers [gcc, clang]
  #                   : SDKs [AWS SDK, Coogle Cloud SDK, open-jdk, Tensor Flow], headers
  #                   : and libraries[ocl-icd-dev],
  #                   : Anything related to development and *-dev or *-devl packages.
  # 6. other          : Everything which doesnot fit in the above categories.
  #                   : Themes, Tools, Utilities like htop etc.
  # 7. External       : Any packages which are provided by ppas, or repositories not present in
  #                   : base *buntu distribution. There's a possibility that the repository might not
  #                   : be added or may be unavailable or offline. So Keeping the list seperate from
  #                   : others packages minimizes errors if there are any.
  # This classification is only for ease of use and need not be strictly followed. You can put
  # vlc package in 'security', it will still install fine. This classification helps
  # while writing configs and editing them. Its advised to follow it if your configs
  # tend to get to couple of hundreds of lines. Also YAML file should be a valid YAML.

  #--------------------------------------------------------------------------------
  #                             Special list - Purge list
  #--------------------------------------------------------------------------------
  # There is a special package list under key, config.purge or purge.list, which contains
  # list of apt packages to be purged from the system if present.
  # Lets get em, shall we?

  # Copy package array
  declare -gar parsed_purge_packages=("${config__purge_[@]}")
  declare -gar parsed_administration_packages=("${config__install__apt__administration_[@]}")
  declare -gar parsed_secutity_packages=("${config__install__apt__security_[@]}")
  declare -gar parsed_productivity_packages=("${config__install__apt__productivity_[@]}")
  declare -gar parsed_multimedia_packages=("${config__install__apt__multimedia_[@]}")
  declare -gar parsed_development_packages=("${config__install__apt__development_[@]}")
  declare -gar parsed_other_packages=("${config__install__apt__other_[@]}")
  declare -gar parsed_external_packages=("${config__install__apt__external_[@]}")

  #--------------------------------------------------------------------------------
  #                             PPA Lists
  #--------------------------------------------------------------------------------
  # Config file contains list of PPAs to be added under key
  # config.ppa
  declare -gar parsed_ppa_list=("${config__ppa_[@]}")

  #--------------------------------------------------------------------------------
  #                             Debian packages
  #--------------------------------------------------------------------------------
  # Config file contains list of DEB packages to be downloaded & installed under key
  # config.install.debian_packages
  # The configuration is not simple URL its csv. <URL to Deb file>,<Name of the Package>
  # This is for compatiblity reasons
  declare -gar parsed_deb_files_list=("${config__install__debian_packages_[@]}")

  #--------------------------------------------------------------------------------
  #                             Python Modules
  #--------------------------------------------------------------------------------
  # There are two keys under config.install.python(2/3) which contain Python 2 and Python 3
  # Modules respectively. Please donot mix python 2 Modules with Python 3.

  declare -gar parsed_pip2_packages=("${config__install__python2_[@]}")
  declare -gar parsed_pip3_packages=("${config__install__python3_[@]}")
  declare -gar parsed_bin_packages=("${config__install__binaries_[@]}")

  #--------------------------------------------------------------------------------
  #                             Snap Packages
  #--------------------------------------------------------------------------------
  declare -gar parsed_snap_normal_packages=("${config__install__snaps__normal_[@]}")
  declare -gar parsed_snap_classic_packages=("${config__install__snaps__classic_[@]}")
  declare -gar parsed_snap_edge_packages=("${config__install__snaps__edge_[@]}")

}


function _clean_apt_cache()
{
  # Function to clean apt package cache. Takes care of -k flag in all the installs.
  # Honor -k flag
  # Delete DEBs
  _log_debug "Cleaning APT packages..."
  if [ "$bool_preserve_debs" != "true" ];then
    _log_and_show "${_deleting} APT Cached Packages"
    apt-get -q clean | _add_timestamp_to_logs "${_apt_logs}"
  else
    _log_debug "Keeping cached APT Packages because -k flag is set."
  fi

}


function _install_dependencies()
{
  # Install packages mentioned in the arguments.
  # If installation fails exit the script.
  # ARG 1: Packages in quote separated by space.
  local packages=("$@")
  _log_debug "Installing Packages"
  {
    _log_debug "Following packages will be installed\n"
    _log_debug "[$(date)] ${_array} %s\n" "${packages[@]}"
  } >> "${log_file}"
  # Check if array is empty
  if [[ ${#packages[@]} -eq 0 ]]; then
    _log_warn "Package array is empty!" "19"
  else
    apt-get -q -y --no-install-recommends install "${packages[@]}" |& _add_timestamp_to_logs "${_apt_logs}"  \
    || _log_and_exit "Failed to install dependencies. Script cannot continue!!" "21"

    exit_status=$?
    if [ $exit_status -eq 0 ]; then
       _log_success "${_installed} dependency packages."
    else
      _log_error "Something went wrong while installing dependencies."
      _log_and_exit "${_notice} Please see the log file for more details." "21"
    fi
  _clean_apt_cache
  fi
}


function _install_pre_requisites()
{
  # This function installs required packages for adding apt repositories
  # These should be present in your base Ubuntu install. If not present then, this function
  # will install them.
  # Following are the packages installed by this function:
  # linux-image-extra-<>, apt-transport-https, ca-certificates,
  # curl, software-properties-common
  local pre_requisite_packages=(apt-transport-https ca-certificates curl gnupg2)
  _log_and_show "${_installing} Necessary dependencies..."
  _log_debug "Dependencies are apt-transport-https, ca-certificates, curl, gnupg2"
  _install_dependencies "${pre_requisite_packages[@]}"

}


function _fix_repo_not_available()
{
  # If repository is not available for latest Ubuntu release, this uses last stable release
  # (may not be LTS) for adding repository
  if [ "$bool_fix_repo_not_available_for_latest" == "true" ]; then
    # Only do this on latest releases
    if [ "$code_name" == "$code_name_latest_release" ]; then
      # check LTS fallback flag is being used
      if [ "$bool_fix_repo_lts" == "true" ]; then
        _log_info "${_notice} Using LTS release ::${codename_lts_fallback}:: as fallback for --fix"
        code_name="$codename_lts_fallback"
      else
        _log_and_show "${_notice} Using previous release ${codename_previous_release} as fallback"
        code_name="$codename_previous_release"
      fi
    else
      _log_debug "This Release/Distro does not support this flag. --fix will be ignored."
    fi
  else
    _log_debug "Feature --fix/--fix-mode-lts is disabled."
  fi
}


function _fix_repo_not_available_upcoming_release()
{
  # If repository is not available for upcoming  release, this uses last stable release
  # Aka if the pre-release release is 18.04 it might use 17.10 if used with --fix, it will use 18.04 repos.
  # With Debian If release is 11, when used with this flag we will use Debian 10 repos.
  # --fix is not valid in case of Debian, only --pre-release applies.

  # check for fix-pre-release flag
  if [ "$bool_fix_repo_not_available_for_upcoming_release" == "true" ]; then

    # Only do this on upcoming-release
    if [ "$code_name" == "$codename_upcoming_release" ] && [ "$bool_is_debian" != "true" ]; then
      _log_warn "Repositories from older Ubuntu release are being used."
      set_yellow
      printf "${_pre_release} You need to modify this in Software and Updates,\n"
      printf "${_pre_release} when they become available for ${codename_upcoming_release}${NC}\n"
      set_default
        # If the repositories are  not available for latest stable release as well, go back a release.
        # Eg. If the pre-release is 18.04 and the repo is not available for 17.10 as well, we use 17.04 repositories.
        # Usually happens in first few days of development cycle of 18.04.
        if [ "$bool_fix_repo_not_available_for_latest" == "true" ]; then
          # We need to use repositories for previous stable release.
          _log_and_show "${_pre_release} Both falgs for --pre-release and -fix are set. Using codename: $codename_previous_release"
          code_name="$codename_previous_release"
        else
          # No need to apply fix for latest release, We can use latest stable release repositories
          _log_and_show "${_pre_release} Using repositories for current stable release: $code_name_latest_release"
          code_name="$code_name_latest_release"
        fi
    elif [ "$code_name" == "$codename_upcoming_debian_release" ] && [ "$bool_is_debian" == "true" ]; then
        _log_and_show "${_pre_release} Using repositories for current stable Debian release: $code_name_latest_debian_release"
        code_name="$code_name_latest_release"
    else
        _log_debug "This release/distribution does not support this option. Flag --pre-release will be ignored."
    fi
  else
    _log_debug "Feature fix_repo_not_available_upcoming_release is disabled."
  fi
}


function add_ppas()
{
  # Function to add ppa by reading ppas from ppa.list of from YAML key config.ppa
  # List/Config file should contain ppas in following format
  # ppa:ppa:<author>/<ppa> for example, ppa:mozillateam/firefox-nex for adding firefox next/Beta PPA
  _log_debug "Adding PPA Fucntion"
  local index;
  local _ppa_dependencies=(apt-transport-https ca-certificates curl gnupg2 software-properties-common)
  # Function Reads the file ${dir}/data/ppa.index and adds the ppa one by one.
  # Install dependencies required
  if [ "$bool_is_debian" != "true" ]; then
    _install_pre_requisites;
    _install_dependencies "${_ppa_dependencies[@]}"

      for index in "${parsed_ppa_list[@]}"; do
            _log_and_show "${_ppa} $index"
            # Check for empty lines
            if [ "$index" == "" ]; then
              _log_and_show "${_ppa} Found and empty entry Moving on to next.."
              continue
            fi
            if add-apt-repository -y "$index" |& _add_timestamp_to_logs "${_ppa_logs}" ; then
              _log_success "${_ppa} Success!"
            else
              _log_error "Some Error occured while adding $index. Ignoring and moving on.\n"
            fi
        done
  else
    _log_and_show "${_ppa} This is Debian. PPAs are not available."
  fi
  _line_fill >> "$log_file"
}


function add_repositories()
{
  # This function adds repositories for several apps like
  # Google Chrome, Spotify, Google Cloud SDK, GCSFUSE(Part of google cloud),
  # Skype, Docker, Skype, Microsoft Visual Studio Code, Google Earth, Insync client, Wine-HQ etc
  # WARNING: Some repositories might not support latest version of Ubuntu.

  #local CLOUD_SDK_REPO
  local GCSFUSE_REPO
  local exit_status
  # install dependencies required
  _install_pre_requisites;
  # if repository is not available for latest ubuntu release, use previous release
  # Be careful, things might not be compatible
  _fix_repo_not_available_upcoming_release;
  _fix_repo_not_available;
  _log_debug "Adding External Repositories"


  if [ "$ARCH" != "amd64" ]; then
    _log_notice "Chrome, Spotify, Insync, VSCode, Mendeley, signal and Duo Unix are only supported on 64 Bit"
  else
    _log_debug "Arch is 64 Bit Enable adding 64 bit repos."
    # 64 bit Only REPOS
    # Add Google Chrome and Google Earth
    if [ "$add_google_repo" == "true" ]; then
      _log_and_show "${_repo} Google Chrome & Google Earth"
      _log_debug "Adding Google package signing Key"
      wget -q  https://dl.google.com/linux/linux_signing_key.pub -O /tmp/ae/google_signing_key.pub >> $"$log_file"
      _log_debug "Adding Google key to trusted keys list"
      apt-key add /tmp/ae/google_signing_key.pub |& _add_timestamp_to_logs "${_apt_key_logs}" \
      || _log_error "Adding trusted keys for Google failed."

      _log_and_show "${_repo} Google Chrome"
      echo "deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main #Google-Chrome" > ${SOURCES_FILE_DIR}/google-chrome.list \
      || _log_error "Adding Google Chrome Repository failed"

      _log_and_show "${_repo} Google Earth"

      echo "deb [arch=amd64] http://dl.google.com/linux/earth/deb/ stable main #Google-Earth" > ${SOURCES_FILE_DIR}/google-earth.list \
      || _log_error "Adding Google Chrome repository failed"
    else
      _log_info "${_repo} Skipped Google chrome, Google Earth"
    fi


    # Spotify client
    if [ "$add_spotify_repo" == "true" ]; then
      _log_and_show "${_repo} Spotify"
      _log_debug "Adding Spotify keys"
      wget -q   https://download.spotify.com/debian/pubkey.gpg -O /tmp/ae/spotify_signing_key.pub >> $"$log_file"
      apt-key add /tmp/ae/spotify_signing_key.pub  2>&1 \
      |_add_timestamp_to_logs "${_apt_key_logs}"  \
      || _log_error "Adding Spotify repository failed"

      echo "deb [arch=$ARCH] http://repository.spotify.com stable non-free #Spotify" > ${SOURCES_FILE_DIR}/spotify.list \
      || _log_error "Adding Spotify Repository Failed"
    else
      _log_info "${_repo} Skipped Spotify."
    fi

    # Insync
    if [ "$add_insync_repo" == "true" ] && [ "$bool_is_debian" != "true" ]; then
      _log_and_show "${_repo} Insync"
      _log_debug "Adding Insync keys"
      apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys ACCAF35C  2>&1 \
      | _add_timestamp_to_logs "${_apt_key_logs}" \
      || _log_error "Adding Insync Repository failed"

      echo "deb [arch=$ARCH] http://apt.insynchq.com/${distro_name} $code_name non-free contrib #Insync-Client" > ${SOURCES_FILE_DIR}/insync.list \
      || _log_error "Adding Insync Repository failed"

    elif [ "$add_insync_repo" == "true" ] && [ "$bool_is_debian" == "true" ]; then
      _log_warn "${_whoops} InSync repositoris are not supported on Debian."
      _log_warn "${_info} Please use debfile instead of repositoris."
      _log_notice "${_info} Visit https://ae.prasadt.com/tasks/#install-debian-package-archives-deb-files"
    else
      _log_info "${_repo} Skipped InSync"
    fi


    # Google Cloud SDK and GCS-FUSE
    if [ "$add_googlecloud_repo" == "true" ] || [ "$add_gcsfuse_repo" == "true" ]; then
      _log_debug "Adding Google-Cloud repository sigining key"
      wget -q https://packages.cloud.google.com/apt/doc/apt-key.gpg -O /tmp/ae/googlecloud.gpg >> "$log_file"
      apt-key add /tmp/ae/googlecloud.gpg |& _add_timestamp_to_logs "${_apt_key_logs}"
    else
      _log_debug "Neither GCSFUSE nor Google cloud SDK install enabled. Not adding Google cloud APT keys"
    fi

    if [ "$add_googlecloud_repo" == "true" ]; then
      #CLOUD_SDK_REPO="cloud-sdk-${code_name}"
      _log_and_show "${_repo} Google-Cloud-SDK"
      echo "deb [arch=$ARCH] http://packages.cloud.google.com/apt cloud-sdk main #Google-Cloud-SDK" > ${SOURCES_FILE_DIR}/google-cloud-sdk.list  \
      || _log_error "Adding Google Cloud SDK Repository failed"
    else
      _log_info "${_repo} Skipped Google Cloud SDK."
    fi

    if [ "$add_gcsfuse_repo" == "true" ]; then
      GCSFUSE_REPO="gcsfuse-${code_name}"
      _log_and_show "${_repo} GCSFUSE"
      echo "deb http://packages.cloud.google.com/apt $GCSFUSE_REPO main #GCSFUSE" > ${SOURCES_FILE_DIR}/gcsfuse.list  \
      || _log_error "Adding GCSFUSE Repository failed"
    else
      _log_info "${_repo} Skipped GCSFUSE"
    fi

    # Skype
    if [ "$add_skype_repo" == "true" ]; then
      _log_and_show "${_repo} Skype for Linux"
      _log_debug "Getting Skype repository key"
      wget -q https://repo.skype.com/data/SKYPE-GPG-KEY -O /tmp/ae/skype-linux-key.gpg >> "$log_file"
      _log_debug "Adding Skype keys to trusted list"
      apt-key add /tmp/ae/skype-linux-key.gpg |& _add_timestamp_to_logs "${_apt_key_logs}" \
      || _log_error "Adding Skype for linux key failed"
      echo "deb [arch=$ARCH] https://repo.skype.com/deb stable main #Skype" > $SOURCES_FILE_DIR/skype-stable.list \
      || _log_error "Adding Skype for linux repository failed"
    else
      _log_info "${_repo} Skipped Skype for Linux."
    fi

    # Visual Studio Code
    if [ "$add_vscode_repo" == "true" ]; then
      _log_and_show "${_repo} Visual Studio Code"
      _log_debug "Getting GPG keys for repository"
      wget -q https://packages.microsoft.com/keys/microsoft.asc -O /tmp/ae/microsoft.asc
      _log_debug "Adding Key to trusted GPG keys directory"
      apt-key add /tmp/ae/microsoft.asc |& _add_timestamp_to_logs "${_apt_key_logs}" || _log_error "Adding Visual Studio Code key failed"
      echo "deb [arch=amd64] https://packages.microsoft.com/repos/vscode stable main #Visual-Studio-Code" > ${SOURCES_FILE_DIR}/vscode.list
    else
      _log_info "${_repo} Skipped Visual Studio Code."
    fi

    # Signal App
    if [ "$add_signal_repo" == "true" ]; then
      _log_and_show "${_repo} Signal Desktop"
      wget -q https://updates.signal.org/desktop/apt/keys.asc -O /tmp/ae/signal.asc >> "$log_file"
      apt-key add /tmp/ae/signal.asc  |& _add_timestamp_to_logs "${_apt_key_logs}" \
      || _log_error "Adding Signal Key Failed"
      echo "deb [arch=amd64] https://updates.signal.org/desktop/apt xenial main #Signal-for-Desktop"  > ${SOURCES_FILE_DIR}/signal-xenial.list
    else
      _log_info "${_repo} Skipped Signal Desktop."
    fi

    # Mendeley Desktop App
    if [ "$add_mendeley_repo" == "true" ]; then
      _log_and_show "${_repo} Mendeley Desktop"
      apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 6F036044 |& _add_timestamp_to_logs "${_apt_key_logs}" \
      || _log_error "Adding Mendeley Desktop Key Failed"
      echo "deb [arch=$ARCH] https://desktop-download.mendeley.com/download/apt stable main #Mendeley-Desktop"  > ${SOURCES_FILE_DIR}/mendeleydesktop.list
    else
      _log_info "${_repo} Skipped Mendeley Desktop"
    fi

    # Duo Unix
    if [ "$add_duo_repo" == "true" ]; then
      _log_and_show "${_repo} Duo Security for Unix"
      case "$code_name" in
        bionic)     duo_repo_url="http://pkg.duosecurity.com/Ubuntu bionic main";
                    duo_supported="true"
                    ;;
        xenial)     duo_repo_url="http://pkg.duosecurity.com/Ubuntu xenial main"
                    duo_supported="true"
                    ;;
        trusty)     duo_repo_url="http://pkg.duosecurity.com/Ubuntu trusty main";
                    duo_supported="true"
                    ;;
        stretch)    duo_repo_url="http://pkg.duosecurity.com/Debian stretch main";
                    duo_supported="true"
                    ;;
        jessie)     duo_repo_url="http://pkg.duosecurity.com/Debian stretch main";
                    duo_supported="true"
                    ;;
        *)          _log_warn "Only LTS/Stable versions of Ubuntu/Debian are suported."
                    _log_warn "You are running Unsupported version : ${code_name}"
                    ;;
      esac
      if [[ $duo_supported == "true" ]]; then
        # Repo keys for duosecurity
        _log_debug "Downloading GPG key..."
        wget -q https://duo.com/APT-GPG-KEY-DUO  -O /tmp/ae/duosecurity.gpg >> "$log_file"
        apt-key add /tmp/ae/duosecurity.gpg |& _add_timestamp_to_logs "${_apt_key_logs}" \
        || _log_error "Adding Duo Key Failed"

        # Add repo
        echo "deb [arch=$ARCH] ${duo_repo_url} #Duo Unix"  > ${SOURCES_FILE_DIR}/duounix.list
      fi
    else
      _log_and_show "${_repo} Duo Unix is set to false."
    fi

  # End if ARCH==64 Check
  fi

  #Wine HQ
  if [ "$add_winehq_repo" == "true" ]; then
    _log_and_show "${_repo} WineHQ"
    _log_debug "Getting WineHQ repository Key"
    wget -q https://dl.winehq.org/wine-builds/winehq.key -O /tmp/ae/wine-hq-sigining-key.key >> "$log_file"  2>&1
    _log_debug "Adding WineHQ key"
    apt-key add /tmp/ae/wine-hq-sigining-key.key |& _add_timestamp_to_logs "${_apt_key_logs}" \
    || _log_error "Adding WineHQ keys failed"
    _log_debug "Adding WineHQ repository"
    echo "deb https://dl.winehq.org/wine-builds/${distro_name}/ ${code_name} main #WineHQ" > ${SOURCES_FILE_DIR}/winehq.list \
    || _log_error "Adding WineHQ repository failed"
  else
    _log_and_show "${_repo} Skipped WineHQ."
  fi

  # Docker CE
  if [ "$add_docker_repo" == "true" ]; then
    if [ "$ARCH" == "amd64" ] || [ "$ARCH" == "armhf" ]; then
      _log_and_show "${_repo} Docker-CE"
      _log_debug "Getting Docker-CE repository Key"
      wget -q https://download.docker.com/linux/"${distro_name}"/gpg -O /tmp/ae/docker-key.gpg >> "$log_file"  2>&1
      _log_debug "Adding Docker repository key"
      apt-key add /tmp/ae/docker-key.gpg |& _add_timestamp_to_logs "${_apt_key_logs}" \
      || _log_error "Adding Docker-CE keys failed"
      _log_debug "Adding Docker-CE sources .list"
      echo "deb [arch=$ARCH] https://download.docker.com/linux/${distro_name}  ${code_name} stable #Docker-Community-Edition" > ${SOURCES_FILE_DIR}/docker.list \
      || _log_error "Adding Docker-CE repository failed"
    else
      _log_error "Architecture not supported!. Please use docker.io package from your distro."
    fi
  else
    _log_debug "Skipped Docker-CE"
  fi



  # ROS
  # Arch support varies on distro so lot of ugly elifs.
  # Packages share same name across RC and Stable. so its not possible to
  # use both RC(ros-shadow-fixed and ros) repos at the same time.
  # rusty will reach EOL soon, ITs not supported and its complicated due to
  # http://wiki.ros.org/indigo/Installation/Ubuntu
  # Dependency issues which might pop up.
  ros_arch_supported="false"


  if [ "$add_ros_repo" == "true" ]; then

    # Distro/Version/Arch checks
    if [[ $distro_name == "ubuntu" ]]; then
        # Check architectures
        # Bionic
        if [[ $code_name == "bionic" ]]; then
          if [[ $ARCH == "amd64" ]] || [[ $ARCH == "arm64" ]] || [[ $ARCH == "armhf" ]]; then
            ros_arch_supported="true"
            _log_and_show "${_repo} ROS is available on Bionic/$ARCH"
          fi

        elif [[ $code_name == "xenial" ]]; then
          if [[ $ARCH == "amd64" ]] || [[ $ARCH == "arm64" ]] || [[ $ARCH == "armhf" ]] || [[ $ARCH == "i386" ]]; then
            ros_arch_supported="true"
            _log_and_show "${_repo} ROS is available on Xenial/$ARCH"
          fi
        fi
    fi #ubuntu

    if [ "$distro_name" == "debian" ]; then
        # Check architectures
        # stretch | jessie
        if [[ $code_name == "stretch" ]] || [[ $code_name == "jessie" ]]; then
          if [[ $ARCH == "amd64" ]] || [[ $ARCH == "arm64" ]] ; then
            ros_arch_supported="true"
            _log_and_show "${_repo} ROS is available on Debian ${code_name}/$ARCH"
          fi
        fi
    fi #debian

    if [[ $ros_arch_supported == "true" ]]; then
      _log_and_show "${_repo} ROS is Supported on this distro/ARCH : ${code_name}/${ARCH}"
      _log_debug "Adding ROS repo key(latest)..."
      apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654 |& _add_timestamp_to_logs "${_apt_key_logs}"  \
       || _log_error "Adding ROS repository key failed!"

       if [[ $bool_use_uni_freiburg_mirror == "true" ]] && [[ $distro_name == "ubuntu" ]]; then
         _log_warn "Using Uni-Freiburg Mirror! This mirror might not be upto date with primary ROS repository!."
         _log_warn "You may need authentication or have to be inside Uni-Freiburg network!"
         echo "deb http://packages.ros.org.ros.informatik.uni-freiburg.de/ros/ubuntu ${code_name} main #ROS-Repo-Uni-Freiburg" > $SOURCES_FILE_DIR/ros-latest.list \
         || _log_error "Adding ROS [Uni-Freiburg] repository failed!"
      else
        echo "deb http://packages.ros.org/ros/ubuntu ${code_name} main #ROS-Repo" > $SOURCES_FILE_DIR/ros-latest.list \
        || _log_error "Adding ROS repository failed!"
       fi

    else
      _log_error "ROS is not supported on this distro/architecture!"
    fi # ros_arch_supported

  else
    _log_and_show "${_repo} Adding ROS repository is set to false, skipping..."
  fi # add_ros_repo


  # Enable Canonical Partner repos
  # Some Releases like linux mint have their own way of enabling partner repositories,
  # Disable adding partner Repositoris when using Ubuntu Derivatives like Linux Mint.
  # Default is true
  # _fix_ubuntu_derivatives will take care of this and bool_config_partner_repo is set to true only if
  # Ubuntu and its flavors are used.
  if [ "$bool_config_partner_repo" == "true" ] && [ "$bool_is_debian" != "true" ]; then
    _log_and_show "${_repo} Canonical partner repositoris"
    echo "deb http://archive.canonical.com/ubuntu $code_name partner # Canonical Partner Repository"  > ${SOURCES_FILE_DIR}/canonical-partner.list \
    || _log_error "Failed to add Canocial Parner Repos."
  else
    _log_warn "Canonical Partner repositories may not be supported on this platform."
  fi

  # Remove artifacts and keys
  _log_debug "Removing keys and converted files from current directory"
  (
    rm  -f /tmp/ae/*.gpg /tmp/ae/*.asc /tmp/ae/*.pub /tmp/ae/Release \
        /tmp/ae/*.Release /tmp/ae/*.key /tmp/ae/*.pub.* /tmp/ae/*.asc.* \
        /tmp/ae/*.key.* /tmp/ae/*.gpg.* >> "$log_file"
  )
  _line_fill >> "$log_file"

  update_repos

}


function update_repos()
{
  local exit_status
  _log_and_show "${_update} Repository index/metadata..."
  apt-get -q update |& _add_timestamp_to_logs "${_apt_logs}"
  exit_status=$?
  if [[ $exit_status -eq 0 ]]; then
    _log_success "${_update} Success!"
  else
    _log_error "Something went wrong in updating repo data. Please see the log file for more details."
    _log_error "Your system might end up completely broken and apt-get isn't reliable in this state."
    _log_error "The script cannot proceed with this."
    _log_and_exit "Command apt-get update failed and exited with ${exit_status}" "61"
  fi
}


function upgrade_apps()
{
  # This function will list up-gradable apps and upgrade it.
  # IF Simulate is set to true this will only list the apps but no upgrade action will be performed.
  local exit_status
  _log_and_show "${_upgrade} Packages..."
  _log_trace "List of upgradable packages if any is listed below."
  _line_fill >> "$log_file"
  # upgradable is not available in apt-get ignore warning about apt being unstable
  apt list --upgradable |& _add_timestamp_to_logs "${_apt_logs}"  \
  || _log_and_show "Something went wrong while listing upgradable packages. Please see the log file or run in debug mode for details."

  _log_debug "The list of packages will be upgraded!"
  # only do upgrades if simulate is set to false
  if [ "$simulate_apt_install" != "true" ]; then

    DEBIAN_FRONTEND=noninteractive apt-get -q -y upgrade |& _add_timestamp_to_logs "${_apt_logs}"
    DEBIAN_FRONTEND=noninteractive apt-get -o Dpkg::Options::="--force-confdef" -o Dpkg::Options::="--force-confold" --allow-remove-essential --allow-change-held-packages -fuy dist-upgrade \
    | _add_timestamp_to_logs "${_apt_logs}"
    exit_status=$?
  else
    # If  simulate is true, set exit status as 0
    # Simulate flag skips the section above. No point in Checking for exit status
    _log_warn "Simulate is set to True. Not performing upgrade!"
    exit_status=0
  fi
  if [[ $exit_status -eq 0 ]]; then
    _log_success "${_upgrade} Completed successfully!"
  else
    _log_warn "${_oh_no} Something went wrong while upgrading packages."
    _log_warn "${_notice} Please see the log file for more details. \
    Most of the times its either missing repositories or wrongly configured repositories."
  fi
  set_default;
  # Cleanup APT cache (-k)
  _clean_apt_cache;

  _line_fill >> "$log_file"
}


function  upgrade_system()
{
  _log_debug "Updating and upgrading packages"
  update_repos;
  upgrade_apps;
}


function purge_ppa()
{
  # PPAs added or repositories added by actions other than this script are not removed.
  # Simulate option has no effect on this function. PPAs will be purged irrespective of its value.
  local exit_status index dependency_packages
  dependency_packages=(ppa-purge)

  if [ "$enable_ppa" == "true" ]; then
    _log_and_show "${_purge} PPAs"
    _install_dependencies "${dependency_packages[@]}"
      for index in "${parsed_ppa_list[@]}"; do
            _log_and_show "${_purge} $index..."
            _log_debug "Purging: $index"
            if [ "$index" == "" ] || [ "$index" == " " ]; then
              _log_warn "${_purge} Found an empty entry, Ignoring"
              continue;
            fi
            if ppa-purge -y "$index"  |& _add_timestamp_to_logs "${_apt_logs}"  ; then
              sleep 5 #wait sometimes apt lock isnt released soon.
              _log_success "${_purge} $line successfully."
            else
              _log_warn "${_oh_no} Some Error occured while purging $line."
            fi
        done
      _log_warn "${_purge} External PPAs."

      # Clean -k flag.
      _clean_apt_cache;
      _log_and_show "${_purge} Complete. Please check the logs for errors."

  else
    _log_warn "PPA's are not available for this release/distro"
  fi
}


function disable_external_repos()
{
  # Function to disable external repositories added by this script.
  # PPAs added or repositories added by actions other than this script are not removed.
  # Repositories added by dpkg post install scripts and deb files will not be removed!!
  # Simulate option has no effect on this function. PPAs will be purged irrespective of its value.

    # Remove keys and list files.
    _log_and_show "${_deleting} Keys and external repositories"
    _log_and_show "${_info} You can igore failed messages if those were not added in first place."
    set_default
    _log_and_show "${_deleting} Google signing key   7FAC5991"
    apt-key del 7FAC5991  |& _add_timestamp_to_logs "${_apt_key_logs}"  \
    || _log_warn "${_deleting}  Google signing key -1 failed."

    _log_and_show "${_deleting} Google signing key   D38B4796"
    apt-key del D38B4796  |& _add_timestamp_to_logs "${_apt_key_logs}"  \
    || _log_warn "${_deleting}  Google signing key -2 failed."

    _log_and_show "${_deleting} GCP signing key -2   BA07F4FB"
    apt-key del BA07F4FB  |& _add_timestamp_to_logs "${_apt_key_logs}"  \
    || _log_warn "${_deleting}  Google cloud key -1 failed."

    _log_and_show "${_deleting} GCP signing key -2   A7317B0F"
    apt-key del A7317B0F  |& _add_timestamp_to_logs "${_apt_key_logs}"  \
    || _log_warn "${_deleting}  GCP signing key -2  failed."

    _log_and_show "${_deleting} Spotify signing key  E130D1D45"
    apt-key del E130D1D45  |& _add_timestamp_to_logs "${_apt_key_logs}"  \
    || _log_warn "${_deleting}  Spotify signing key failed."

    _log_and_show "${_deleting} WineHQ key [latest]  F987672F"
    apt-key del F987672F  |& _add_timestamp_to_logs "${_apt_key_logs}"  \
    || _log_warn "${_deleting}  WineHQ keys [latest] failed."

    _log_and_show "${_deleting} InSync signing key   ACCAF35C"
    apt-key del ACCAF35C  |& _add_timestamp_to_logs "${_apt_key_logs}"  \
    || _log_warn "${_deleting}  InSync keys failed."

    _log_and_show "${_deleting} Docker signing key   0EBFCD88"
    apt-key del 0EBFCD88  |& _add_timestamp_to_logs "${_apt_key_logs}"  \
    || _log_warn "${_deleting}  Docker-CE keys failed."

    _log_and_show "${_deleting} VS-Code signing key  BE1229CF"
    apt-key del BE1229CF  |& _add_timestamp_to_logs "${_apt_key_logs}"  \
    || _log_warn "${_deleting}  Visual Studio Code keys failed."

    _log_and_show "${_deleting} Signal signing key   57F6FB06"
    apt-key del 57F6FB06  |& _add_timestamp_to_logs "${_apt_key_logs}"  \
    || _log_warn "${_deleting}  Signal keys failed."

    _log_and_show "${_deleting} Mendeley signing key 6F036044"
    apt-key del 57F6FB06  |& _add_timestamp_to_logs "${_apt_key_logs}"  \
    || _log_warn "${_deleting}  Mendeley Desktop keys failed."

    _log_and_show "${_deleting} ROS signing key B01FA116"
    apt-key del 421C365BD9FF1F717815A3895523BAEEB01FA116  |& _add_timestamp_to_logs "${_apt_key_logs}"  \
    || _log_warn "${_deleting}  ROS keys failed."

    _log_and_show "${_repo} Removing external repositoris"
    _log_debug "${_deleting} *.list and *.save files from ${SOURCES_FILE_DIR}"
    (
      cd /etc/apt/sources.list.d &&
        rm  -f google-chrome.* \
        google-earth.* \
        skype-stable.* \
        spotify.* \
        insync.* \
        google-cloud-sdk.* \
        gcsfuse.* \
        docker.* \
        winehq.* \
        vscode.* \
        signal-xenial.* \
        mendeleydesktop.* \
        ros-latest.*
    )
    exit_status=$?

    if [[ $exit_status -eq 0 ]]; then
      _log_and_show "${_removed} Additional APT keys and repositories."
      _log_and_show "${_notice} Canonical partner repository was left unchanged."
    else
      _log_warn "${_oh_no} Failed to remove all or some of the list files or keys in Sources directory."
      _log_warn "${_notice} Please see the log file for more details."
    fi
    _log_notice "${_removed} Repositories. Please check the logs for errors."

    _line_fill >> "$log_file"

}

function purge_not_required()
{
  # This function purges not required packages from the list ${dir}/data/purge.list
  # A flag -d MUST be passed for this option to work
  # Not passing a flag and choosing purge will result in error and action being aborted.
  # Simulate is not properly tested and use it with caution!
  # Combination of simulate and purge is UNSTABLE
  # You can modify -d requirement by setting the d_flag_passed=true
  # No validation/checks are done on the list file.
  # Action is dangerous if used carelessly eg. If you are stupid and remove say sudo (why would you??)

  local exit_status
  if [ "$bool_purge_not_required_pkgs" == "true" ]; then
    _log_and_show "${_purge} Packages..."

    if [[ ${#parsed_purge_packages[@]} -eq 0 ]]; then
      _log_error "Package array is empty!";
      return;
    else
      if [ "$simulate_apt_install" == "true" ]; then
        _log_warn "Purging will be simulated!!"
      apt-get -q -y remove --purge --dry-run "${parsed_purge_packages[@]}" |& _add_timestamp_to_logs "${_apt_logs}"
      else
        apt-get -q -y purge "${parsed_purge_packages[@]}" |& _add_timestamp_to_logs "${_apt_logs}"
      fi
      exit_status=$?

      if [[ $exit_status -eq 0 ]]; then
        _log_success "${_purge} Success!"
      else
        _log_warn "${_oh_no} Something went wrong while purging packages."
        _log_warn "${_notice} Please see the log file for more details."
      fi
    fi

  else
    _log_and_exit "Purge switch is set to false. Did you pass -d along with the command?" "20"
  fi
  _line_fill >> "$log_file"

}


function install_apps()
{
  # Function to install apps mentioned in arrays
  # external-repos should always be at last to avoid any errors in previous .
  # No checks are being made on any of the files for validity. One entry per line is recommended.
  # If a package is not available entire collection in the file *.list will not be installed!!

  # Accept some EULA
  update_repos;
  echo ttf-mscorefonts-installer msttcorefonts/accepted-mscorefonts-eula select true |  debconf-set-selections
  #Install starts here
  local packages exit_status index
  #shellcheck disable=SC2034
  readonly local package_arrays=(
                              administration
                              security
                              productivity
                              multimedia
                              development
                              other
                              external
                              )
  for array in "${package_arrays[@]}"; do
    case "${array}" in
      administration)         packages=("${parsed_administration_packages[@]}");;
      security)               packages=("${parsed_secutity_packages[@]}");;
      productivity)           packages=("${parsed_productivity_packages[@]}");;
      multimedia)             packages=("${parsed_multimedia_packages[@]}");;
      development)            packages=("${parsed_development_packages[@]}");;
      other)                  packages=("${parsed_other_packages[@]}");;
      external)               packages=("${parsed_external_packages[@]}");;
      *)                      _log_and_exit "Critical error. Invalid array type" "19";;
    esac
    _log_and_show "${_apt} Installing $array packages"

    # Chek if array is empty
    if [[ ${#packages[@]} -eq 0 ]]; then
      _log_warn "${_notice} Package array is empty!";
      continue
    else
      _log_debug "Following packages will be installed."
      printf "[$(date)] ${_array} %s\n" "${packages[@]}" >> "${log_file}"
      # Check if simulate is true
      if [ "$simulate_apt_install" == "true" ]; then
        _log_warn "Simulating package installation."
        apt-get -q -y install -s "${packages[@]}" | _add_timestamp_to_logs "${_apt_logs}"
      else
        apt-get -q -y install "${packages[@]}" | _add_timestamp_to_logs "${_apt_logs}"
      fi
      exit_status=$?
      unset packages;
      if [[ $exit_status -eq 0 ]]; then
        _log_success "${_apt} Success!"
      else
      _log_warn "${_oh_no} Something went wrong while installing packages in $array."
      _log_warn "${_notice} Please see the log file for more details."
      fi

    fi
    unset packages
  done
  {
    _line_fill
    #declare -p
    _line_fill
  } >> "$log_file"
  # Delete DEBs
  _clean_apt_cache;

  _line_fill >> "$log_file"
}


function _install_pip_python()

{
  # Function to install python pip packages
  # This function reads from File ${dir}/data/pip.list contains list python packages to be installed system wide.
  # Arguments : Two
  # ARG1 : pip package list
  # ARG2 : 2 for python 2 and
  #      : 3 for Python 3.

  #Check args
  if [ $# -lt 1 ] ||  [ $# -gt 1 ] ; then

    _log_error "Incorrect number of arguments.\
     \n${_info} Usage: _check_and_install_pre_requisites <list.apt> <commands to check>\n" && \
    _log_and_exit "Internal Function Error. Invalid number of Arguments: $#." "19";
  fi;


  #Install starts here
  local exit_status pip_command pip_loc python_packages requirements_file
  local pip_ver="${1}"
  _log_debug "Option: Install Python packages via PIP, Function name: _install_pip_python"
  _log_debug "pip Version : ${pip_ver}"

  # Check Python Version
  case ${pip_ver} in
    2 | python2 )   readonly pip_command="pip"
                    dependency_packages=(python-pip python-setuptools)
                    python_packages=("${parsed_pip2_packages[@]}")
                    requirements_file="/tmp/ae/requirements2.txt"
                    ;;
    3 | python3 )   readonly pip_command="pip3";
                    dependency_packages=(python3-pip python3-setuptools)
                    python_packages=("${parsed_pip3_packages[@]}")
                    requirements_file="/tmp/ae/requirements3.txt"
                    ;;
              * )   _log_and_exit "Internal Function Error. Arguments for python version." "19";;
  esac

  _log_and_show "${_checking} Dependencies for Python: ${pip_ver}"

  # Check if `python-pip` is installed, if not install it
  if ! pip_loc="$(type -p "$pip_command")" || [[ -z $pip_loc ]]; then
      _log_info "${_info} $pip_command is not installed!${NC}"
      update_repos;
      _log_and_show "${_installing} PIP Dependencies"

      # Check if simulate flag is set
      if [ "$simulate_apt_install" == "true" ] && [ "$AE_INTERNAL_CI_MODE" != "true" ]; then
        _log_warn "Simulating! No Dependencies will be installed!!"
        # shellcheck disable=SC2086
        apt-get -q -y -s --no-install-recommends install "${dependency_packages[@]}" |& _add_timestamp_to_logs "${_apt_logs}"
      elif [ "$simulate_apt_install" == "true" ] && [ "$AE_INTERNAL_CI_MODE" == "true" ]; then
        _log_dev "This is CI disregarding --simulate flag"
        apt-get -q -y --no-install-recommends install "${dependency_packages[@]}" |& _add_timestamp_to_logs "${_apt_logs}"
      else
        # shellcheck disable=SC2086
        apt-get -q -y --no-install-recommends install "${dependency_packages[@]}" |& _add_timestamp_to_logs "${_apt_logs}"
      fi
      exit_status=$?

      if [[ $exit_status -eq 0 ]]; then
        _log_success "${_installed} Dependency packages."
      else
        _log_warn "${_oh_no} Something went wrong while installing dependencies."
        _log_error "Python packages cannot be installed without dependencies."
        _log_and_exit "${_notice} Please see the log file for more details." "21"
      fi

      ## honor --keep-debs -k flags
      _clean_apt_cache;

  else
    _log_and_show "${_info} Dependency already satisfied."
  fi
  # reset exit status & color
  exit_status=0
  set_default;


  _log_and_show "${_installing} Installing python packages"
  _log_debug "Requirements file: ${requirements_file}"
   rm -f ${requirements_file} || _log_and_exit "Failed to remove ${requirements_file}" "38"
   printf "%s\n" "${python_packages[@]}" > "${requirements_file}"
  # Check if pip package list is empty
  if [[ ${#python_packages[@]} -eq 0 ]]; then
    _log_error "Package array is empty!";
    return
  else
    # I package list isn't empty proceed to install pip packages
    # Check if simulate is true & is not running on TRAVIS/CI.
    if [ "$simulate_apt_install" == "true" ] && [ "$AE_INTERNAL_CI_MODE" != "true" ]; then
      _log_warn "${_whoops} PIP does not support simulated installs. Not performing install."
    elif  [ "$simulate_apt_install" == "true" ] && [ "$AE_INTERNAL_CI_MODE" == "true" ]; then
      _log_dev "This is CI disregarding --simulate flag!"
      $pip_command install -r "${requirements_file}" |& _add_timestamp_to_logs "${_pip_logs}"
    else
      _log_debug "Installing requirements file ${requirements_file}"
      $pip_command install -r "${requirements_file}" |& _add_timestamp_to_logs "${_pip_logs}"

    fi
    exit_status=$?
    if [[ $exit_status -eq 0 ]]; then
      _log_success "${_installed} python - ${1} modules"
    else
      _log_error "Something went wrong while installing packages in $pip_list."
      _log_warn "${_notice} Please see the log file for more details."
    fi
  fi

  _line_fill >> "$log_file"
}


function install_pip_packages_2()
{
  # Install Python 2 packages
  if [[ $python2_disabled == "true" ]]; then
    _log_error "Python2 is not supported on this platform!"
  else
    _install_pip_python "2"
  fi
}


function install_pip_packages_3()
{
  # Install Python 2 packages
  _install_pip_python "3"
}


function install_debs ()
{

  # Function to get the deb files from DEB_URL in the ${dir}/data/deb_files.list
  # The list file has following format
  # URL to get the deb file  <space or tab> NAME_OF_THE_APP(without spaces)

  local index deb_url line deb_name
  local exit_status
  _log_debug "Option: Install DEB Files, Function name: install_debs"
  for index in "${parsed_deb_files_list[@]}"; do
    _log_debug "$index"
    deb_url=$(echo "$index" | cut -d ',' -f1 )
    deb_name=$(echo "$index" | cut -d ',' -f2 )
    _log_debug "DEB file url: $deb_url"
    _log_debug "DEB file name: $deb_name"

    if [[ -z $deb_url ]] || [[ -z $deb_name ]]; then
      _log_error "Malformed entry either URL or name is empty!"
      continue
    fi

    _log_and_show "${_deb} Downloading $deb_name"
    {
      wget -q "$deb_url" -O "${deb_name}" >> "$log_file"
    } ||
    {
      _log_error "Downloading $deb_name failed."
      continue
    }

   _log_and_show "${_deb} Installing - $deb_name..."
   # Check if simulate is true
   if [ "$simulate_apt_install" == "true" ]; then
     _log_warn "Simulating $deb_name Installation!!"
     dpkg -i --dry-run "$deb_name" |& _add_timestamp_to_logs "${_dpkg_logs}"

     _log_debug "Installing missing packages..."
     apt-get -q -y install -f |& _add_timestamp_to_logs "${_apt_logs}"
     exit_status=$?
    else
      dpkg -i "$deb_name" |& _add_timestamp_to_logs "${_dpkg_logs}"
      _log_debug "Installing missing packages..."
      apt-get -q -y install -f |& _add_timestamp_to_logs "${_apt_logs}"
      exit_status=$?
    fi

    # shellcheck disable=SC2181
     if [ "$exit_status" = "0" ]; then
      _log_success "${_ok} Installed $deb_name successfully."
     else
      _log_warn "${_oh_no} Some error occurred during downloading and installing $index."
      $?="0"
    fi
    # Delete DEBs
    if [ "$bool_preserve_debs" == "false" ];then
      _log_and_show "${_deb} Deleting downloaded DEB Packages"
      (
        rm -f "${dir}/${deb_name}" >> "$log_file"
      )
    else
      _log_debug "Keeping downloaded DEB packages"
    fi
  done

  _clean_apt_cache;
  _line_fill >> "$log_file"
}


function install_binaries ()
{

  # Function to get the binaries files from URL in the ${dir}/data/bin.list
  # The list file has following format
  # <URL>,<filename>
  # If you want to specify relative path you
  # can do so relative to /usr/local/bin
  # Be careful not to rename existing ones

  local index bin_url line bin_name
  local exit_status
  _log_debug "Option: Install Bin Files, Function name: install_binaries"
  # Check if simulate is true
  for index in "${parsed_bin_packages[@]}"; do
    _log_debug "$index"
    bin_url=$(echo "$index" | cut -d ',' -f1 )
    bin_name=$(echo "$index" | cut -d ',' -f2 )
    _log_debug "BIN file url: $bin_url"
    _log_debug "BIN file name: $bin_name"

    if [[ -z $bin_url ]] || [[ -z $bin_name ]]; then
      _log_error "Malformed entry either URL or name is empty!"
      continue
    fi
    _log_and_show "${_info} Downloading $bin_name"
    wget -q "$bin_url" -O "/tmp/ae/${bin_name}" >> "$log_file"
    exit_status="$?"
    if [ $exit_status -eq 0 ]; then
      _log_and_show "${_installing} $bin_name..."
       if [ "$simulate_apt_install" == "true" ]; then
         _log_warn "Skipping Installation!!"
       else
        {
          cp -rf "/tmp/ae/${bin_name}" /usr/local/bin/"${bin_name}"
        } || _log_and_show "${_error} Failed to copy $bin_name";
        _log_debug "Setting Permissions..."
        chmod +x /usr/local/bin/"$bin_name" >> "${log_file}"
      fi
    else
      _log_error "Failed to download $bin_name."
    fi
    set_default
  done
  _line_fill >> "$log_file"
}


function __install_snaps()
{
  #Install Snap packages
  local exit_status index snapd_options
  local snap_type
  snap_type="$1"

  case ${snap_type} in
    classic)    snapd_options=("--color=never" "--classic")
                parsed_snaps_list=("${parsed_snap_classic_packages[@]}")
                ;;
    edge)       snapd_options=("--color=never" "--edge")
                parsed_snaps_list=("${parsed_snap_edge_packages[@]}")
                ;;
    normal)     snapd_options=("--color=never")
                parsed_snaps_list=("${parsed_snap_normal_packages[@]}")
                ;;
    * )         _log_and_exit "Internal Function Error. Arguments for snap type." "19";;
  esac

  if [[ ${#parsed_snaps_list[@]} -eq 0 ]]; then
      _log_warn "Snaps array is empty!" "19"
  else
    for index in "${parsed_snaps_list[@]}"; do
      _log_and_show "${_snap} $index"
      if [ "$index" == "" ] || [ "$index" == " " ]; then
        _log_warn "Found an empty entry, Ignoring"
        continue;
      fi

      if [ "$simulate_apt_install" == "true" ]; then
        _log_warn "Snaps do not support --dry-run, skipping installation"
      else
        _log_debug "Options are ${snapd_options[*]}"
        if snap install "${snapd_options[@]}" "$index"  |& _add_timestamp_to_logs "${_snap}"  ; then
          _log_success "$line installed successfully."
        else
          _log_error "Some Error occurred while installing $line."
        fi
      fi
    done
  fi
}


function install_snaps()
{
  local dependency_packages
  dependency_packages=(snapd)

  if [ "$simulate_apt_install" == "true" ]; then
    _log_warn "Will not install dependencies required for installing snap packages"
  else
    _install_dependencies "${dependency_packages[@]}"
  fi

  _log_and_show "${_info} Installing Snap Packages"
  __install_snaps "normal"
    _log_and_show "${_info} Installing classic snap packages"
  __install_snaps "classic"
    _log_and_show "${_info} Installing beta snap packages"
  __install_snaps "edge"

}

function _autopilot_check_task_flag_and_run()
{
  # checks flags set for each task/function and runs it
  # Arguments Two
  # ARG -1 : global flag variable to check
  # ARG -2: Function Name to execute
  local flag=${1}
  local runnable=${2}

  if [ "${flag}" == "true" ]; then
    _log_debug "Executing Function $runnable"
    "$runnable"
  else
    _log_debug "Task : $runnable is not enabled"
  fi
  unset runnable
}


function all_in_one()
{
  #Wrapper for all options
  _log_debug "Option: ALL IN ONE, function name: all_in_one"
  _line_fill;
  set_default;
  update_repos;
  upgrade_apps;
  add_ppas;
  add_repositories;
  install_apps;
  install_debs;
  install_pip_packages_2;
  install_pip_packages_3;
  purge_not_required;
  install_binaries;
  install_snaps;
  set_default;
  _line_fill;

}




function _prompt_confirmation()
{
  # Function to confirm whether action selected should be performed or not.
  # Accepts 2 arguments
  # ARG-2 Message to be displayed in confirmation box
  # ARG-2 name of the function to execute
  # Depends on whiptail
  # To overide and say yes to all dialog pass -y as command line option while running the script.
  local confirm_msg="${1}" #Message shown in Confirmation dialogue
  local exec_function="${2}" #Function to run if user selected yes
  COLUMNS=$(tput cols)
  LINES=$(tput lines)
  export COLUMNS LINES
  if [ "$bool_say_yes_to_all" == "true" ]; then
    _log_debug "Yes to all: No confirm dialog to be displayed."
    _log_debug "Executing: $exec_function"
    $exec_function;
  else
    _log_debug "Confirming  $exec_function."
    # shellcheck disable=SC2086
    if (whiptail  --title "Ubuntu Post-Install Script"  --yesno "$confirm_msg" $LINES $COLUMNS $(( LINES - 12 ))) then
        _log_debug "User selected yes, Proceed with $name_of_task"
        # execute the function
        _log_debug "Executing: $exec_function"
        $exec_function
    else
        _log_debug "Selected No for $name_of_task, Returning to main menu."
        _process_menu;
    fi
  fi
  unset exec_function
}


function _process_menu()
{
  local whiptail_exitstatus task COLUMNS LINES
  _log_debug "Displaying Main menu"
  COLUMNS=$(tput cols)
  LINES=$(tput lines)
  #export COLUMNS LINES
  # shellcheck disable=SC2086
  task=$(whiptail \
      --notags \
      --backtitle "$SCRIPT" \
      --title "Ubuntu Post-Install Script" \
      --menu "\nWhat would you like me to do?" \
      --cancel-button "Quit" \
      $LINES $COLUMNS $(( LINES - 12 )) \
      update     'Update Repository Metadata' \
      upgrade    'Upgrade Packages' \
      repo       'Add Repositories' \
      ppas       'Add PPAs' \
      purge      'Purge not required packages' \
      apps       'Install Packages' \
      debs       'Install DEB packages' \
      pip2       'Install Python 2 packages via pip' \
      pip3       'Install Python 3 packages via pip3' \
      bin        'Download & Install Static Binaries' \
      snaps      'Install snap packages' \
      all        'All the tasks mentioned above' \
      repo_rst   'Reset Repositories for cleanup' \
      ppa_rst    'Purge PPAs' \
      3>&1 1>&2 2>&3)

  __menu_info_add_repo="
  Settings for additional repositories is set as follows.
  -------------------------------------------------------
  Google Chrome, Google Earth : $add_google_repo
  Google Cloud SDK            : $add_googlecloud_repo
  GCS-Fuse                    : $add_gcsfuse_repo
  VS Code                     : $add_vscode_repo
  Docker Community Edition    : $add_docker_repo
  Insync                      : $add_insync_repo
  Skype                       : $add_skype_repo
  Signal Desktop              : $add_signal_repo
  Mendeley                    : $add_mendeley_repo
  ROS                         : $add_ros_repo
  Duo Security for Unix       : $add_duo_repo

  Proceed with this action?
  "

  __menu_info_upgrade="
  This action will upgrage already installed packages on your system.

  Please pin package versions to avoid them from being automatically
  updated.
  -------------------------------------------------------

  Proceed with this action?
  "

  __menu_info_update="
  This action will update repository metadata. This action
  will simple run apt-get update as root.
  -------------------------------------------------------

  Proceed with this action?
  "

  __menu_info_ppa="
  This action will add PPAs from the config to your system.
  Some dependency packages like curl and software-properties
  might get installed to enable adding these PPAs.
  -------------------------------------------------------

  Proceed with this action?
  "

  __menu_info_apps="
  This action will install packages defined in your config.
  As there might be hundreds of packages they are not displayed
  here. Please ensure that packages are valid and are available
  on your distribution. This might take some time depending on
  your Internet connection and CPU.
  -------------------------------------------------------

  Proceed with this action?
  "

  __menu_info_repo_rst="
  This action can remove PPAs and repositories added by
  this script. Please do note that any changes
  not made my this script might be ignored.
  -------------------------------------------------------

  Proceed with this action?
  "

  __menu_info_ppa_rst="
  This action can remove PPAs  added by this script.
  Please do note that any changes not made my this script
  might be ignored. This task will install ppa-purge and
  will revert packages provided by the ppas to the ones
  provided by distriution. Use this with caution!
  -------------------------------------------------------

  Proceed with this action?
  "

  __menu_info_purge="
  This action can remove packages which come
  preinstalled on Ubuntu/Debian installation.
  Use this with caution! Removing a core dependency might
  lead t a broken system!
  -------------------------------------------------------

  Proceed with this action?
  "

  __menu_info_all="
  This will run ALL the tasks except
  deleting logs, purging PPAs and removing repos.

  Order of execution is as follows.

  - Update repository metadata
  - Upgrade packages
  - Add Repositories
  - Add PPAs
  - Install Packages
  - Install DEB files
  - Install Python 2 modules (if supported)
  - Install Python 3 Modules
  - Install Static binaries
  - Install Snap Packages
  -------------------------------------------------------

  Proceed with this action?
  "

  __menu_info_debs="
  This will download and install debian packages mentioned in
  the config file. Please note that this is slightly less secure,
  as GPG signature verification is not done on the packages
  downloaded.
  -------------------------------------------------------

  Proceed with this action?
  "

  __menu_info_pip3="
  This will download and install PIP3 packages. PIP packages will be
  installed as system site packages. Its recommened NOT to use this
  feature except for core system management packages. Either use packages
  provided by system's package manager (It is easier to update them)
  or use virtualenv or per user packages.
  -------------------------------------------------------

  Proceed with this action?
  "

  __menu_info_pip2="
  This will download and install PIP2 packages. PIP packages will be
  installed as system site packages. Its recommened NOT to use this
  feature except for core system management packages. Either use packages
  provided by system's package manager (It is easier to update them)
  or use virtualenv or per user packages.

  ::WARNING::
  Python 2 may not be supported on recent distributions!
  -------------------------------------------------------

  Proceed with this action?
  "

  __menu_info_snaps="
  Install snap packages. If your system did not come preinstalled with
  snapd, it will be installed. If you are running a DNS server on the
  machine, lxd's dnsmasq might cause port conflicts.

  You must specify snaps under correct category.
  - classic (no confinement)
  - normal (default snap confinement)
  - edge (beta versions and some unconfined packages)

  ::WARNING::
  This task will fail inside docker containers!
  -------------------------------------------------------

  Proceed with this action?
  "

  __menu_info_bin="
  Install static binaries. This task will download and put
  your binaries in /usr/local/bin. Please ensure to use correct
  binaries for your system and ensure that
  /usr/local/bin is in your PATH.
  -------------------------------------------------------

  Proceed with this action?
  "

  whiptail_exitstatus=$?
  _log_debug "Whiptail Exit status is : $whiptail_exitstatus"
  if [ $whiptail_exitstatus = 0 ]; then
      _log_debug "Whiptail Task is: $task"
      case $task in
      update)     _prompt_confirmation "$__menu_info_update" "update_repos"
                  ;;
      upgrade)    _prompt_confirmation "${__menu_info_upgrade}" "upgrade_apps"
                  ;;
      ppas)       _prompt_confirmation "${__menu_info_ppa}" "add_ppas"
                  ;;
      repo)       _prompt_confirmation "$__menu_info_add_repo" "add_repositories"
                  ;;
      apps)       _prompt_confirmation "$__menu_info_apps" "install_apps"
                  ;;
      repo_rst)   _prompt_confirmation "${__menu_info_repo_rst}" "disable_external_repos"
                  ;;
      ppa_rst)    _prompt_confirmation "${__menu_info_ppa_rst}" "purge_ppa"
                  ;;
      purge)      _prompt_confirmation "${__menu_info_purge}" "purge_not_required"
                  ;;
      all)        _prompt_confirmation "${__menu_info_all}" "all_in_one"
                  ;;
      debs)       _prompt_confirmation "${__menu_info_debs}" "install_debs"
                  ;;
      pip2)       _prompt_confirmation "${__menu_info_pip2}" "install_pip_packages_2"
                  ;;
      pip3)       _prompt_confirmation "${__menu_info_pip3}" "install_pip_packages_3"
                  ;;
      bin)        _prompt_confirmation "${__menu_info_bin}" "install_binaries"
                  ;;
      snaps)      _prompt_confirmation "${__menu_info_snaps}" "install_snaps"
                  ;;
    esac
  else
    _log_debug "Whiptail Exit code : $whiptail_exitstatus"
    _log_debug "Exiting because user selected Quit or Whiptail has non zero exit code."
  fi
}


function _ci_cloud_and_container_checks()
{

  if [ "$bool_skip_env_checks" == "true" ]; then
    _log_debug "Skipping Run environment checks"
  else
    _log_and_show "${_running} Env checks..."
    # Check if running in CI & Containers
    # VMs, GCP, AWS, Docker.
    #================================ CI =============================================
    if [ "$TRAVIS" == "true" ]; then
      _log_and_show "${_ci} Running on Travis CI"
    elif [ "$APPVEYOR" == "true" ]; then
      _log_and_show "${_ci} Running on Appveyor CI"
    elif [ "$TF_BUILD" == "True" ]; then
      _log_and_show "${_ci} Running on Azure Pipelines"
    elif [ "$GITHUB_ACTIONS" == "true" ]; then
      _log_and_show "${_ci} Running on GitHub Actions"
    fi

    # Internal checks
    if [ "$AE_INTERNAL_CI_MODE" == "true" ]; then
      _log_dev "Enforcing CI MODE"
      _log_dev "This is to be used only while testing the script."
      _log_dev "This will ignore --simulate flag in some cases!!"
    fi

    if [ "$(uname -r | cut -f3 -d '-')" == "Microsoft" ]; then
      _log_warn "Running on Windows Subsystem for Linux"
    fi
    #============================ Docker =============================================
    if grep docker /proc/1/cgroup -qa; then
      _log_and_show "${_info} Running in Docker."
      #AE_RUNNING_IN_DOCKER=1
    else
      _log_debug "Probably not running in docker"
    fi
    #------------------------------- EC2, GCP, DO ------------------------------------
    # This first, simple check will work for many older instance types.
    if [ -f /sys/hypervisor/uuid ] && [ "$(head -c 3 /sys/hypervisor/uuid)" == "ec2" ]; then
      _log_and_show "${_info} Running on EC2"

    # This check will work on newer m5/c5 instances, but only if you have root!
    # If the file exists AND is readable by us, we can rely on it.
    elif [ -r /sys/devices/virtual/dmi/id/product_uuid ] && [ "$(head -c 3 /sys/devices/virtual/dmi/id/product_uuid)" == "EC2" ]; then
      _log_and_show "${_info} Running on EC2"

    # Fallback check of http://169.254.169.254/. If we wanted to be REALLY
    # authoritative, we could follow Amazon's suggestions for cryptographically
    # verifying their signature, see here:
    #    https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-identity-documents.html
    # but this is almost certainly overkill for this purpose (and the above
    # checks of "EC2" prefixes have a higher false positive potential anyway).
    elif wget -O- -q --timeout=1 --tries=1 http://169.254.169.254/latest/dynamic/instance-identity/document | grep -q availabilityZone; then
      _log_and_show "${_info} Running on EC2"

    #------------------------------- GCP ---------------------------------------------
    elif wget -q -O- --timeout=1 --tries=1 -nc --header="Metadata-Flavor: Google" http://169.254.169.254/computeMetadata/v1/instance/virtual-clock/drift-token > /dev/null; then
      _log_and_show "${_info} Running on Google Compute"

    elif wget -q -O- --timeout=1 --tries=1 -nc  http://169.254.169.254/metadata/v1/id; then
      _log_and_show "${_info} Running on Digital Ocean Droplet"

    elif AZURE_REGION="$(wget -q -O- --timeout=1 --tries=1 --header "Metadata:true" "${AZURE_METADATA_URL}")"; then
      _log_and_show "${_info} Running on AZURE ${AZURE_REGION}"

    else
      _log_debug "Probably not running on AWS, GCP, Azure or Digital Ocean."
    fi

  fi

}

function display_version()
{
  printf "%-15s : %s\n" "Version Number" "${REL_NUM}"
  printf "%-15s : %s\n" "Version Name" "${REL_NAME}"
  printf "%-15s : %s\n" "Executable" "${SCRIPT}"
}


function display_usage()
{
#Prints out help menu
cat <<EOF
${GREEN}
A Post Installation Script for Ubuntu/Debian/Linux Mint${NC}
Usage: ${GREEN} [sudo] ./${SCRIPT} ${YELLOW}  [options]${NC}
${YELLOW}
Non-Action options (can be run as non-root user)
-------------------------------------------------${NC}
[-v --version]     Display version info
[-h --help]        Display this help message
${YELLOW}
Configuration Options
-------------------------------------------------${NC}
[-c | --config-file]   Local yaml config file
[-R | --remote-yaml]   Use config yaml hosted somewhere else
${BLUE}
The following options are "action" options and
will make changes to your system depending on tasks chosen.
-------------------------------------------------${NC}
[-d | --purge]         Enable Purging packages
[-f | --fix]           Fix codenames for new releases
[-p | --pre-release]   Same as --fix but for beta/alpha releases
[--fix-mode-lts]       Similar to --fix but fallback to last LTS
                       Should be used with --fix
[-k | --keep-debs]     Do not invoke apt-clean & do not delete
                       downloaded deb packages
[-l | --delete-log]    Delete logfile (./log/after-effects.log)
[-s | --simulate]      Try not make changes to system and use --dry-run
                       Please read the documentation, to know its limits
                       as everything cannot be simulated.
${YELLOW}
Other Options
-------------------------------------------------${NC}
[-E | --skip-env-checks]     Skip some env checks
[-V | --skip-version-check]  Skip checking for latest version
[-H --hide-config]           Hide configuration table
[-A --autopilot]             Enables AUTOPILOT mode(No Prompts)
${GREEN}
Links & License
-------------------------------------------------${NC}
GitHub          : ${BLUE}https://git.io/Jv08V${NC}
Documentation   : ${BLUE}https://ae.prasadt.com${NC}
* This script is licensed under GPLv3.
* Show your support by starring the repo on GitHub
-------------------------------------------------
EOF
}

function _process_non_root_options()
{
  # Process command line arguments which does not require root.
  if [[  $# -eq 0 ]]; then
    set_red
    printf "Error! No arguments specified! See Usage Below\n"
    set_default
    display_usage
    exit 1
  elif [[  $# -eq 1 ]]; then
    while [ "${1}" != "" ]; do
      case ${1} in
        -v | --version)   display_version;
                          exit 0;
                          ;;
        -G | --verify)    verify_gpg_signature;
                          exit 0;
                          ;;
      -l | --delete-log)  delete_log_file;
                          ;;
      -L | --lists)       set_red;
                          printf "${_error} List mode is no longer supported.";
                          set_default;
                          exit 53;;
        -h | --help)      display_usage;
                          exit 0;
                          ;;
        *)                printf "${_error} This does not appear to be a valid option\n";
                          printf "${_error} Non action options take more than one argument!\n";
                          exit 1;
                          ;;
      esac
      shift
    done
  fi
}


function main()
{
  _init_printf_variables

  # Display Version Info and Verify signature options
  _process_non_root_options "$@"

  _line_fill;
  printf "${_checking} Permissions...\n"

  if [[ $AE_INTERNAL_NO_EXECUTE -eq 1 ]]; then
    # Actual logging starts
    _init_logging
    _log_dev "Running in no Execute mode"
  elif [[ $EUID -ne 0 ]]; then
    set_red;
    printf "${_whoops} Insufficient privileges!!\n"
    printf "${_error} This script must be run as root.\n"
    printf "${_error} Please use sudo ${dir}/$SCRIPT to run this as root.\n"
    set_default;
    _line_fill;
    exit 2;
  else
    # We were not running in NX mode, and we are root.
    _init_logging
    _log_success "${_ok} OK! running as root."
  fi

  # Init vars
  _init_script_variables;

  # Process command line arguments.
  while [ "${1}" != "" ]; do
    case ${1} in
      -s | --simulate)        readonly simulate_apt_install="true";
                              _log_warn "Simulate is set to true";
                             ;;
      -f | --fix)             bool_fix_repo_not_available_for_latest="true";
                              _log_info "${_fix} Fix codename is set to true.";
                              ;;
      --fix-mode-lts)         bool_fix_repo_lts="true";
                              _log_info "${_fix} Fix mode is set to LTS: $codename_lts_fallback.";
                              ;;
      -p | --pre-release)     bool_fix_repo_not_available_for_upcoming_release="true";
                              set_magenta;
                              _log_and_show "Codename fix for upcoming release is set to true.";
                              set_default;
                              ;;
      -d | --purge)           bool_purge_not_required_pkgs="true";
                              _log_and_show "${_purge} Purge packages is set to true."
                              _log_warn "No checks are being made on the packages in the list."
                              _log_warn "Use carefully!. Purging system packages is stupid idea!"
                              ;;
      -y | --yes)             _log_warn "-y | --yes is no longer availanle, Use Autopilot instead";
                              ;;
      -k | --keep-debs)       bool_preserve_debs="true";
                              _log_and_show "${_info} Will keep downloaded DEB packages."
                              ;;
  -V | --skip-version-check)  bool_check_version="false";
                              ;;
      --version-file)         shift;
                              readonly custom_version_file="${1}";
                              readonly bool_custom_version_file="true"
                              _log_and_show "${_info} Using custom version yml file"
                              ;;
      -R | --remote-yaml)     _log_and_show "${_info} Using Remote YAML";
                              readonly bool_remote_yaml="true";
                              shift;
                              readonly url_remote_yaml="${1}";
                              ;;
    -c | --config-file)       shift;
                              readonly custom_config_file="${1}";
                              readonly bool_custom_config_file="true";
                              _log_and_show "${_info} Using local config file"
                              ;;
    -H | --hide-config)       readonly bool_hide_config="true";
                              _log_and_show "${_info} YAML config will not be displayed."
                              ;;
      --internal-ci-mode)     readonly AE_INTERNAL_CI_MODE="true";;
      -A | --autopilot)       readonly AE_AUTOPILOT="true";;
      --use-uf-mirror)        _log_and_show "Will use Uni-Freiburg mirror(s) if available";
                              readonly bool_use_uni_freiburg_mirror="true";
                              ;;
      -E | --skip-env-checks) readonly bool_skip_env_checks="true";;
      # The following arguments should always be used as the only arguments.
      -l | --delete-logfile)  _log_and_exit "-l or --delete-logfile should be the only argument." "23";;
      -v | --version)         _log_and_exit "-v or --version should be the only argument." "23";;
      -G | --verify)          _log_and_exit "--verify should be the only argument." "23";;
       -h | --help)           _log_and_exit "-h or --help should be the only argument." "23";;
       *)                     _log_and_exit "Invalid option: $1" "22";;
    esac
    shift
  done


  # Initialize variables and checks
  local after_effects_core_dependencies=(wget whiptail ping ps grep cut tr awk)
  _check_dependencies "${after_effects_core_dependencies[@]}"

  _init_print_basic_info;

  # I don't like when someone else is occupying my room
  # Test if any apt-get ops are running
  _test_conflicting_apps;

  # Did I tell you that I need to call My friends over internet?
  _test_internet_connection;

  # Checks CI & Containers If running on EC2/GCP/Azure/DO
  _ci_cloud_and_container_checks;

  # Take care of Mint and other distros
  _fix_ubuntu_derivatives;


  if [ "$bool_custom_config_file" == "true" ] && [ "$bool_remote_yaml" == "true" ]; then
    _log_and_exit "Cannot use local config (-c) with remote YAML (-R) Use one of them." "25"
  fi

  if [ "$bool_custom_config_file" == "true" ] && [ ! -f "$custom_config_file" ]; then
    _log_and_exit "Config file you have specified is not found or not accessible" "36"
  fi

  if [ "$bool_custom_version_file" == "true" ] && [ ! -f "$custom_version_file" ]; then
    _log_and_exit "Custom version info file you have specified is not found or not accessible" "36"
  fi

  # Handle Remote YAML

  if [ "$bool_remote_yaml" == "true" ]; then
    _log_debug "Will use config from ${url_remote_yaml}"
  elif [ "$bool_custom_config_file" == "true" ]; then
    _log_debug "Config file specified will be used."
  fi

  # Version, Config and GPG signature URLS
  _log_debug "Version Info URL is: ${api_version_url}"

  # Get Remote Config File/s, check version & configure
  _version_checks;

  _set_yaml_config;

  if [[ ! -t 1 ]] && [[ $AE_AUTOPILOT != "true" ]]; then
    _log_error "Terminal is not interactive, yet you have not specified --autopilot flag!"
    _log_and_exit "Non Interactive Terminal requires --autopilot" "54"
  fi

  if [[ $AE_INTERNAL_NO_EXECUTE -eq 1 ]]; then
    _log_dev "Will not execute any tasks!"
    _script_exit_log;
    exit 255
  fi

  # Autopilot
  if [[ ${AE_AUTOPILOT} == "true" ]]; then
    bool_say_yes_to_all="true"
    _log_notice "${_autopilot} Active"
    sleep 3;
    #_log_and_exit "Because I can" "255"
    _autopilot_check_task_flag_and_run "$ae_task_update" "update_repos"
    _autopilot_check_task_flag_and_run "$ae_task_upgrade" "upgrade_apps"
    _autopilot_check_task_flag_and_run "$ae_task_repo" "add_repositories"
    _autopilot_check_task_flag_and_run "$ae_task_ppa" "add_ppas"
    _autopilot_check_task_flag_and_run "$ae_task_apt" "install_apps"
    _autopilot_check_task_flag_and_run "$ae_task_debs" "install_debs"
    _autopilot_check_task_flag_and_run "$ae_task_pip2" "install_pip_packages_2"
    _autopilot_check_task_flag_and_run "$ae_task_pip3" "install_pip_packages_3"
    _autopilot_check_task_flag_and_run "$ae_task_purge" "purge_not_required"
    _autopilot_check_task_flag_and_run "$ae_task_bin" "install_binaries"
    _autopilot_check_task_flag_and_run "$ae_task_snaps" "install_snaps"
  else
    sleep 2
    _process_menu;
  fi

  _script_exit_log;
}

#Run Main
main "$@"
